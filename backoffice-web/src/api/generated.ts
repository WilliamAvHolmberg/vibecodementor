/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * API
 * Clean Architecture API with JWT Authentication
 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

export interface ATACommentDetails {
  id?: string;
  /** @nullable */
  content?: string | null;
  /** @nullable */
  authorName?: string | null;
  createdAt?: string;
}

export interface ATACommentForApprovalDto {
  id?: string;
  /** @nullable */
  content?: string | null;
  /** @nullable */
  authorName?: string | null;
  createdAt?: string;
}

export interface ATADetailsResponse {
  id?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  projectName?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  recipientEmail?: string | null;
  /** @nullable */
  requestedBy?: string | null;
  status?: ATAStatus;
  totalCost?: number;
  createdAt?: string;
  updatedAt?: string;
  /** @nullable */
  lineItems?: ATALineItemDetails[] | null;
  /** @nullable */
  comments?: ATACommentDetails[] | null;
  /** @nullable */
  timeline?: ATATimelineEntry[] | null;
}

export interface ATAForApprovalResponse {
  id?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  projectName?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  requestedBy?: string | null;
  status?: ATAStatus;
  totalCost?: number;
  createdAt?: string;
  /** @nullable */
  lineItems?: ATALineItemForApprovalDto[] | null;
  /** @nullable */
  comments?: ATACommentForApprovalDto[] | null;
  /** @nullable */
  timeline?: ATATimelineForApprovalDto[] | null;
}

export interface ATALineItemDetails {
  id?: string;
  type?: ATAWorkType;
  /** @nullable */
  description?: string | null;
  costEstimate?: number;
  /** @nullable */
  comment?: string | null;
  createdAt?: string;
}

export interface ATALineItemForApprovalDto {
  type?: ATAWorkType;
  /** @nullable */
  description?: string | null;
  costEstimate?: number;
  /** @nullable */
  comment?: string | null;
}

export interface ATARequestSummary {
  id?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  projectName?: string | null;
  /** @nullable */
  recipientEmail?: string | null;
  status?: ATAStatus;
  totalCost?: number;
  lineItemCount?: number;
  createdAt?: string;
  updatedAt?: string;
}

export type ATAStatus = typeof ATAStatus[keyof typeof ATAStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ATAStatus = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_3: 3,
  NUMBER_4: 4,
} as const;

export interface ATATimelineEntry {
  id?: string;
  status?: ATAStatus;
  /** @nullable */
  comment?: string | null;
  /** @nullable */
  changedBy?: string | null;
  /** @nullable */
  changedByName?: string | null;
  timestamp?: string;
  submissionRound?: number;
}

export interface ATATimelineForApprovalDto {
  id?: string;
  status?: ATAStatus;
  /** @nullable */
  comment?: string | null;
  /** @nullable */
  changedBy?: string | null;
  /** @nullable */
  changedByName?: string | null;
  timestamp?: string;
  submissionRound?: number;
}

export type ATAWorkType = typeof ATAWorkType[keyof typeof ATAWorkType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ATAWorkType = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export interface AddSubtaskRequest {
  /** @nullable */
  title?: string | null;
}

export interface AddSubtaskResponse {
  taskId?: string;
  /** @nullable */
  taskTitle?: string | null;
  /** @nullable */
  subtaskTitle?: string | null;
  subtaskCount?: number;
  addedAt?: string;
}

export type ApplicationRole = typeof ApplicationRole[keyof typeof ApplicationRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationRole = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export interface ApproveATARequestDto {
  /** @nullable */
  comment?: string | null;
}

export interface ApproveATARequestResponse {
  ataId?: string;
  newStatus?: ATAStatus;
  /** @nullable */
  message?: string | null;
}

export interface AssignRoleRequest {
  role: ApplicationRole;
}

export interface ChatMessageDto {
  id?: string;
  /** @nullable */
  userName?: string | null;
  /** @nullable */
  message?: string | null;
  timestamp?: string;
  /** @nullable */
  connectionId?: string | null;
  /** @nullable */
  messageType?: string | null;
  isSystemMessage?: boolean;
}

export interface ChatMessageResponseDto {
  id?: string;
  /** @nullable */
  role?: string | null;
  /** @nullable */
  content?: string | null;
  order?: number;
  createdAt?: string;
}

export interface ChatSessionSummaryResponseDto {
  sessionId?: string;
  createdAt?: string;
  updatedAt?: string;
  messageCount?: number;
  isCurrent?: boolean;
}

export interface CheckInHabitCommand {
  habitId?: string;
  /** @nullable */
  userId?: string | null;
  isSuccess?: boolean;
  /** @nullable */
  reflection?: string | null;
}

export interface CheckInHabitResponse {
  checkInId?: string;
  habitId?: string;
  date?: string;
  isSuccess?: boolean;
  /** @nullable */
  reflection?: string | null;
  completedAt?: string;
}

export interface CreateATALineItemDto {
  type?: ATAWorkType;
  /** @nullable */
  description?: string | null;
  costEstimate?: number;
  /** @nullable */
  comment?: string | null;
}

export interface CreateATARequestDto {
  /** @nullable */
  title?: string | null;
  /** @nullable */
  projectName?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  recipientEmail?: string | null;
  /** @nullable */
  requestedBy?: string | null;
  /** @nullable */
  lineItems?: CreateATALineItemDto[] | null;
}

export interface CreateATARequestResponse {
  id?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  projectName?: string | null;
  totalCost?: number;
  createdAt?: string;
}

export interface CreateBoardRequest {
  /** @nullable */
  title?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface CreateBoardResponse {
  boardId?: string;
  /** @nullable */
  title?: string | null;
  createdAt?: string;
}

export interface CreateChatSessionRequest {
  boardId?: string;
}

export interface CreateChatSessionResponse {
  sessionId?: string;
  boardId?: string;
  createdAt?: string;
}

export interface CreateDraftATAResponse {
  id?: string;
  createdAt?: string;
}

export interface CreateHabitCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  userId?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface CreateHabitResponse {
  habitId?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  createdAt?: string;
}

export interface CreateSuperAdminRequest {
  /** @nullable */
  email?: string | null;
  /** @nullable */
  firstName?: string | null;
  /** @nullable */
  lastName?: string | null;
}

export interface CreateSuperAdminResponse {
  /** @nullable */
  userId?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  message?: string | null;
}

export interface CreateTaskRequest {
  /** @nullable */
  title?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  columnName?: string | null;
}

export interface CreateTaskResponse {
  taskId?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  columnName?: string | null;
  createdAt?: string;
}

export interface CreateUserRequest {
  /** @minLength 1 */
  email: string;
  /**
   * @minLength 0
   * @maxLength 100
   * @nullable
   */
  firstName?: string | null;
  /**
   * @minLength 0
   * @maxLength 100
   * @nullable
   */
  lastName?: string | null;
  /** @nullable */
  roles?: string[] | null;
}

export interface CreateUserResponse {
  /** @nullable */
  userId?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  fullName?: string | null;
}

export interface CurrentUserResponse {
  /** @nullable */
  userId?: string | null;
  /** @nullable */
  email?: string | null;
  isAuthenticated?: boolean;
  /** @nullable */
  roles?: string[] | null;
}

export interface DeleteUserResponse {
  /** @nullable */
  userId?: string | null;
  deletedAt?: string;
}

export interface FunctionCall {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  arguments?: string | null;
}

export interface GetAllUsersResponse {
  /** @nullable */
  users?: UserListItem[] | null;
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
}

export interface GetBoardChatSessionsResponse {
  boardId?: string;
  /** @nullable */
  currentSessionId?: string | null;
  /** @nullable */
  sessions?: ChatSessionSummaryResponseDto[] | null;
}

export interface GetChatSessionMessagesResponse {
  sessionId?: string;
  boardId?: string;
  /** @nullable */
  messages?: ChatMessageResponseDto[] | null;
}

export interface GetCurrentChatSessionResponse {
  sessionId?: string;
  boardId?: string;
  createdAt?: string;
  updatedAt?: string;
  messageCount?: number;
}

export interface HabitForDayDto {
  habitId?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  isCompleted?: boolean | null;
  /** @nullable */
  reflection?: string | null;
  /** @nullable */
  completedAt?: string | null;
}

export interface KanbanBoardDto {
  id?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  description?: string | null;
  createdAt?: string;
  updatedAt?: string;
  /** @nullable */
  columns?: KanbanColumnDto[] | null;
}

export interface KanbanBoardSummaryDto {
  id?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  description?: string | null;
  createdAt?: string;
  updatedAt?: string;
  taskCount?: number;
  completedTaskCount?: number;
}

export interface KanbanColumnDto {
  id?: string;
  /** @nullable */
  name?: string | null;
  order?: number;
  isCompleted?: boolean;
  /** @nullable */
  tasks?: KanbanTaskDto[] | null;
}

export interface KanbanSubtaskDto {
  /** @nullable */
  title?: string | null;
  isCompleted?: boolean;
  createdAt?: string;
  /** @nullable */
  completedAt?: string | null;
}

export interface KanbanTaskDto {
  id?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  description?: string | null;
  position?: number;
  createdAt?: string;
  updatedAt?: string;
  /** @nullable */
  subtasks?: KanbanSubtaskDto[] | null;
}

export interface LoginRequest {
  /** @nullable */
  email?: string | null;
  /** @nullable */
  password?: string | null;
}

export interface LoginUserResponse {
  /** @nullable */
  token?: string | null;
  /** @nullable */
  email?: string | null;
  expiresAt?: string;
}

/**
 * @nullable
 */
export type MessageContent = unknown | null;

export interface Message {
  /** @nullable */
  role?: string | null;
  /** @nullable */
  content?: MessageContent;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  tool_call_id?: string | null;
  /** @nullable */
  tool_calls?: ToolCall[] | null;
}

export interface ModelPricing {
  /** @nullable */
  prompt?: string | null;
  /** @nullable */
  completion?: string | null;
}

export interface MoveTaskRequest {
  /** @nullable */
  targetColumnName?: string | null;
}

export interface MoveTaskResponse {
  taskId?: string;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  fromColumn?: string | null;
  /** @nullable */
  toColumn?: string | null;
  movedAt?: string;
}

export interface OpenRouterModel {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  context_length?: number;
  pricing?: ModelPricing;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  features?: string[] | null;
}

export interface ProblemDetails {
  /** @nullable */
  type?: string | null;
  /** @nullable */
  title?: string | null;
  /** @nullable */
  status?: number | null;
  /** @nullable */
  detail?: string | null;
  /** @nullable */
  instance?: string | null;
  [key: string]: unknown;
}

export interface RegisterRequest {
  /** @nullable */
  email?: string | null;
  /** @nullable */
  password?: string | null;
}

export interface RegisterUserResponse {
  /** @nullable */
  userId?: string | null;
  /** @nullable */
  email?: string | null;
}

export interface RegisterVisitRequest {
  /** @nullable */
  visitorId?: string | null;
  /** @nullable */
  path?: string | null;
}

export interface RejectATARequestDto {
  /** @nullable */
  comment?: string | null;
}

export interface RejectATARequestResponse {
  ataId?: string;
  newStatus?: ATAStatus;
  /** @nullable */
  message?: string | null;
}

export interface RemoveHabitResponse {
  habitId?: string;
  /** @nullable */
  name?: string | null;
  removedAt?: string;
}

export interface SaveEmailToNewsletterResponse {
  /** @nullable */
  message?: string | null;
  isNewSubscription?: boolean;
}

export interface SendOtpRequest {
  /** @nullable */
  email?: string | null;
}

export interface SendOtpResponse {
  /** @nullable */
  message?: string | null;
  expiresAt?: string;
}

export interface SubmitATARequestResponse {
  ataId?: string;
  newStatus?: ATAStatus;
  /** @nullable */
  message?: string | null;
}

export interface SubscribeToNewsletterRequest {
  /** @nullable */
  email?: string | null;
}

export interface ToggleSubtaskResponse {
  taskId?: string;
  /** @nullable */
  taskTitle?: string | null;
  /** @nullable */
  subtaskTitle?: string | null;
  isCompleted?: boolean;
  toggledAt?: string;
}

export interface ToolCall {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  type?: string | null;
  function?: FunctionCall;
}

export interface UpdateATALineItemDto {
  type?: ATAWorkType;
  /** @nullable */
  description?: string | null;
  costEstimate?: number;
  /** @nullable */
  comment?: string | null;
}

export interface UpdateATALineItemsDto {
  /** @nullable */
  lineItems?: UpdateATALineItemDto[] | null;
}

export interface UpdateATALineItemsResponse {
  ataRequestId?: string;
  lineItemCount?: number;
  totalCost?: number;
  updatedAt?: string;
}

export interface UpdateATARequestDto {
  /** @nullable */
  title?: string | null;
  /** @nullable */
  projectName?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  recipientEmail?: string | null;
  /** @nullable */
  requestedBy?: string | null;
}

export interface UpdateATARequestResponse {
  id?: string;
  updatedAt?: string;
}

export interface UpdateUserRequest {
  /**
   * @minLength 0
   * @maxLength 100
   * @nullable
   */
  firstName?: string | null;
  /**
   * @minLength 0
   * @maxLength 100
   * @nullable
   */
  lastName?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  roles?: string[] | null;
}

export interface UpdateUserResponse {
  /** @nullable */
  userId?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  fullName?: string | null;
  updatedAt?: string;
  /** @nullable */
  updatedRoles?: string[] | null;
}

export interface UserListItem {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  fullName?: string | null;
  createdAt?: string;
  /** @nullable */
  roles?: string[] | null;
}

export interface UserResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  firstName?: string | null;
  /** @nullable */
  lastName?: string | null;
  /** @nullable */
  fullName?: string | null;
  createdAt?: string;
  updatedAt?: string;
}

export interface UserRolesResponse {
  /** @nullable */
  userId?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  roles?: ApplicationRole[] | null;
}

export interface VerifyOtpCookieResponse {
  /** @nullable */
  message?: string | null;
  /** @nullable */
  email?: string | null;
}

export interface VerifyOtpRequest {
  /** @nullable */
  email?: string | null;
  /** @nullable */
  otpCode?: string | null;
}

export interface VisitRegistrationResult {
  isNewVisit?: boolean;
  totalVisits?: number;
  todayVisits?: number;
}

export type GetApiChatMessagesParams = {
take?: number;
before?: string;
};

export type PostApiFilesUploadBody = {
  file?: Blob;
};

export type PostApiFilesUploadImageBody = {
  file?: Blob;
};

export type GetApiFilesImagesLatestParams = {
count?: number;
};

export type GetApiHabitsParams = {
date?: string;
};

export type GetApiKanbanChatStreamParams = {
conversationId?: string;
message?: string;
boardId?: string;
model?: string;
};

export type GetApiOpenrouterToolsChatStreamParams = {
conversationId?: string;
message?: string;
model?: string;
};

export type GetApiUsersParams = {
page?: number;
pageSize?: number;
search?: string;
};

export type postApiAnalyticsVisitResponse200 = {
  data: VisitRegistrationResult
  status: 200
}
    
export type postApiAnalyticsVisitResponseComposite = postApiAnalyticsVisitResponse200;
    
export type postApiAnalyticsVisitResponse = postApiAnalyticsVisitResponseComposite & {
  headers: Headers;
}

export const getPostApiAnalyticsVisitUrl = () => {


  

  return `/api/Analytics/visit`
}

export const postApiAnalyticsVisit = async (registerVisitRequest: RegisterVisitRequest, options?: RequestInit): Promise<postApiAnalyticsVisitResponse> => {
  
  const res = await fetch(getPostApiAnalyticsVisitUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerVisitRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiAnalyticsVisitResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiAnalyticsVisitResponse
}




export const getPostApiAnalyticsVisitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAnalyticsVisit>>, TError,{data: RegisterVisitRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiAnalyticsVisit>>, TError,{data: RegisterVisitRequest}, TContext> => {

const mutationKey = ['postApiAnalyticsVisit'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAnalyticsVisit>>, {data: RegisterVisitRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAnalyticsVisit(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAnalyticsVisitMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAnalyticsVisit>>>
    export type PostApiAnalyticsVisitMutationBody = RegisterVisitRequest
    export type PostApiAnalyticsVisitMutationError = unknown

    export const usePostApiAnalyticsVisit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAnalyticsVisit>>, TError,{data: RegisterVisitRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAnalyticsVisit>>,
        TError,
        {data: RegisterVisitRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAnalyticsVisitMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getResponse200 = {
  data: string
  status: 200
}
    
export type getResponseComposite = getResponse200;
    
export type getResponse = getResponseComposite & {
  headers: Headers;
}

export const getGetUrl = () => {


  

  return `/`
}

export const get = async ( options?: RequestInit): Promise<getResponse> => {
  
  const res = await fetch(getGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getResponse
}



export const getGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getGetQueryOptions = <TData = Awaited<ReturnType<typeof get>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetQueryError = unknown


export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof get>>,
          TError,
          Awaited<ReturnType<typeof get>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof get>>,
          TError,
          Awaited<ReturnType<typeof get>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiATAResponse200 = {
  data: CreateATARequestResponse
  status: 200
}
    
export type postApiATAResponseComposite = postApiATAResponse200;
    
export type postApiATAResponse = postApiATAResponseComposite & {
  headers: Headers;
}

export const getPostApiATAUrl = () => {


  

  return `/api/ATA`
}

export const postApiATA = async (createATARequestDto: CreateATARequestDto, options?: RequestInit): Promise<postApiATAResponse> => {
  
  const res = await fetch(getPostApiATAUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createATARequestDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiATAResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiATAResponse
}




export const getPostApiATAMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATA>>, TError,{data: CreateATARequestDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiATA>>, TError,{data: CreateATARequestDto}, TContext> => {

const mutationKey = ['postApiATA'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiATA>>, {data: CreateATARequestDto}> = (props) => {
          const {data} = props ?? {};

          return  postApiATA(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiATAMutationResult = NonNullable<Awaited<ReturnType<typeof postApiATA>>>
    export type PostApiATAMutationBody = CreateATARequestDto
    export type PostApiATAMutationError = unknown

    export const usePostApiATA = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATA>>, TError,{data: CreateATARequestDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiATA>>,
        TError,
        {data: CreateATARequestDto},
        TContext
      > => {

      const mutationOptions = getPostApiATAMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiATAResponse200 = {
  data: ATARequestSummary[]
  status: 200
}
    
export type getApiATAResponseComposite = getApiATAResponse200;
    
export type getApiATAResponse = getApiATAResponseComposite & {
  headers: Headers;
}

export const getGetApiATAUrl = () => {


  

  return `/api/ATA`
}

export const getApiATA = async ( options?: RequestInit): Promise<getApiATAResponse> => {
  
  const res = await fetch(getGetApiATAUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiATAResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiATAResponse
}



export const getGetApiATAQueryKey = () => {
    return [`/api/ATA`] as const;
    }

    
export const getGetApiATAQueryOptions = <TData = Awaited<ReturnType<typeof getApiATA>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATA>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiATAQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiATA>>> = ({ signal }) => getApiATA({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiATA>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiATAQueryResult = NonNullable<Awaited<ReturnType<typeof getApiATA>>>
export type GetApiATAQueryError = unknown


export function useGetApiATA<TData = Awaited<ReturnType<typeof getApiATA>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATA>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiATA>>,
          TError,
          Awaited<ReturnType<typeof getApiATA>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiATA<TData = Awaited<ReturnType<typeof getApiATA>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATA>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiATA>>,
          TError,
          Awaited<ReturnType<typeof getApiATA>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiATA<TData = Awaited<ReturnType<typeof getApiATA>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATA>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiATA<TData = Awaited<ReturnType<typeof getApiATA>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATA>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiATAQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiATADraftResponse200 = {
  data: CreateDraftATAResponse
  status: 200
}
    
export type postApiATADraftResponseComposite = postApiATADraftResponse200;
    
export type postApiATADraftResponse = postApiATADraftResponseComposite & {
  headers: Headers;
}

export const getPostApiATADraftUrl = () => {


  

  return `/api/ATA/draft`
}

export const postApiATADraft = async ( options?: RequestInit): Promise<postApiATADraftResponse> => {
  
  const res = await fetch(getPostApiATADraftUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiATADraftResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiATADraftResponse
}




export const getPostApiATADraftMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATADraft>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiATADraft>>, TError,void, TContext> => {

const mutationKey = ['postApiATADraft'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiATADraft>>, void> = () => {
          

          return  postApiATADraft(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiATADraftMutationResult = NonNullable<Awaited<ReturnType<typeof postApiATADraft>>>
    
    export type PostApiATADraftMutationError = unknown

    export const usePostApiATADraft = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATADraft>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiATADraft>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostApiATADraftMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type patchApiATAIdResponse200 = {
  data: UpdateATARequestResponse
  status: 200
}
    
export type patchApiATAIdResponseComposite = patchApiATAIdResponse200;
    
export type patchApiATAIdResponse = patchApiATAIdResponseComposite & {
  headers: Headers;
}

export const getPatchApiATAIdUrl = (id: string,) => {


  

  return `/api/ATA/${id}`
}

export const patchApiATAId = async (id: string,
    updateATARequestDto: UpdateATARequestDto, options?: RequestInit): Promise<patchApiATAIdResponse> => {
  
  const res = await fetch(getPatchApiATAIdUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateATARequestDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: patchApiATAIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as patchApiATAIdResponse
}




export const getPatchApiATAIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiATAId>>, TError,{id: string;data: UpdateATARequestDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiATAId>>, TError,{id: string;data: UpdateATARequestDto}, TContext> => {

const mutationKey = ['patchApiATAId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiATAId>>, {id: string;data: UpdateATARequestDto}> = (props) => {
          const {id,data} = props ?? {};

          return  patchApiATAId(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiATAIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiATAId>>>
    export type PatchApiATAIdMutationBody = UpdateATARequestDto
    export type PatchApiATAIdMutationError = unknown

    export const usePatchApiATAId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiATAId>>, TError,{id: string;data: UpdateATARequestDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiATAId>>,
        TError,
        {id: string;data: UpdateATARequestDto},
        TContext
      > => {

      const mutationOptions = getPatchApiATAIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiATAIdResponse200 = {
  data: ATADetailsResponse
  status: 200
}
    
export type getApiATAIdResponseComposite = getApiATAIdResponse200;
    
export type getApiATAIdResponse = getApiATAIdResponseComposite & {
  headers: Headers;
}

export const getGetApiATAIdUrl = (id: string,) => {


  

  return `/api/ATA/${id}`
}

export const getApiATAId = async (id: string, options?: RequestInit): Promise<getApiATAIdResponse> => {
  
  const res = await fetch(getGetApiATAIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiATAIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiATAIdResponse
}



export const getGetApiATAIdQueryKey = (id?: string,) => {
    return [`/api/ATA/${id}`] as const;
    }

    
export const getGetApiATAIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiATAId>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiATAIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiATAId>>> = ({ signal }) => getApiATAId(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiATAId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiATAIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiATAId>>>
export type GetApiATAIdQueryError = unknown


export function useGetApiATAId<TData = Awaited<ReturnType<typeof getApiATAId>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiATAId>>,
          TError,
          Awaited<ReturnType<typeof getApiATAId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiATAId<TData = Awaited<ReturnType<typeof getApiATAId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiATAId>>,
          TError,
          Awaited<ReturnType<typeof getApiATAId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiATAId<TData = Awaited<ReturnType<typeof getApiATAId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiATAId<TData = Awaited<ReturnType<typeof getApiATAId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiATAIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type patchApiATAIdLineitemsResponse200 = {
  data: UpdateATALineItemsResponse
  status: 200
}
    
export type patchApiATAIdLineitemsResponseComposite = patchApiATAIdLineitemsResponse200;
    
export type patchApiATAIdLineitemsResponse = patchApiATAIdLineitemsResponseComposite & {
  headers: Headers;
}

export const getPatchApiATAIdLineitemsUrl = (id: string,) => {


  

  return `/api/ATA/${id}/lineitems`
}

export const patchApiATAIdLineitems = async (id: string,
    updateATALineItemsDto: UpdateATALineItemsDto, options?: RequestInit): Promise<patchApiATAIdLineitemsResponse> => {
  
  const res = await fetch(getPatchApiATAIdLineitemsUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateATALineItemsDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: patchApiATAIdLineitemsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as patchApiATAIdLineitemsResponse
}




export const getPatchApiATAIdLineitemsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiATAIdLineitems>>, TError,{id: string;data: UpdateATALineItemsDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof patchApiATAIdLineitems>>, TError,{id: string;data: UpdateATALineItemsDto}, TContext> => {

const mutationKey = ['patchApiATAIdLineitems'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiATAIdLineitems>>, {id: string;data: UpdateATALineItemsDto}> = (props) => {
          const {id,data} = props ?? {};

          return  patchApiATAIdLineitems(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiATAIdLineitemsMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiATAIdLineitems>>>
    export type PatchApiATAIdLineitemsMutationBody = UpdateATALineItemsDto
    export type PatchApiATAIdLineitemsMutationError = unknown

    export const usePatchApiATAIdLineitems = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiATAIdLineitems>>, TError,{id: string;data: UpdateATALineItemsDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiATAIdLineitems>>,
        TError,
        {id: string;data: UpdateATALineItemsDto},
        TContext
      > => {

      const mutationOptions = getPatchApiATAIdLineitemsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiATAIdSubmitResponse200 = {
  data: SubmitATARequestResponse
  status: 200
}
    
export type postApiATAIdSubmitResponseComposite = postApiATAIdSubmitResponse200;
    
export type postApiATAIdSubmitResponse = postApiATAIdSubmitResponseComposite & {
  headers: Headers;
}

export const getPostApiATAIdSubmitUrl = (id: string,) => {


  

  return `/api/ATA/${id}/submit`
}

export const postApiATAIdSubmit = async (id: string, options?: RequestInit): Promise<postApiATAIdSubmitResponse> => {
  
  const res = await fetch(getPostApiATAIdSubmitUrl(id),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiATAIdSubmitResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiATAIdSubmitResponse
}




export const getPostApiATAIdSubmitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATAIdSubmit>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiATAIdSubmit>>, TError,{id: string}, TContext> => {

const mutationKey = ['postApiATAIdSubmit'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiATAIdSubmit>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  postApiATAIdSubmit(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiATAIdSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof postApiATAIdSubmit>>>
    
    export type PostApiATAIdSubmitMutationError = unknown

    export const usePostApiATAIdSubmit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATAIdSubmit>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiATAIdSubmit>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPostApiATAIdSubmitMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiATAApproveIdResponse200 = {
  data: ATAForApprovalResponse
  status: 200
}
    
export type getApiATAApproveIdResponseComposite = getApiATAApproveIdResponse200;
    
export type getApiATAApproveIdResponse = getApiATAApproveIdResponseComposite & {
  headers: Headers;
}

export const getGetApiATAApproveIdUrl = (id: string,) => {


  

  return `/api/ATA/approve/${id}`
}

export const getApiATAApproveId = async (id: string, options?: RequestInit): Promise<getApiATAApproveIdResponse> => {
  
  const res = await fetch(getGetApiATAApproveIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiATAApproveIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiATAApproveIdResponse
}



export const getGetApiATAApproveIdQueryKey = (id?: string,) => {
    return [`/api/ATA/approve/${id}`] as const;
    }

    
export const getGetApiATAApproveIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiATAApproveId>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAApproveId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiATAApproveIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiATAApproveId>>> = ({ signal }) => getApiATAApproveId(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiATAApproveId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiATAApproveIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiATAApproveId>>>
export type GetApiATAApproveIdQueryError = unknown


export function useGetApiATAApproveId<TData = Awaited<ReturnType<typeof getApiATAApproveId>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAApproveId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiATAApproveId>>,
          TError,
          Awaited<ReturnType<typeof getApiATAApproveId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiATAApproveId<TData = Awaited<ReturnType<typeof getApiATAApproveId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAApproveId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiATAApproveId>>,
          TError,
          Awaited<ReturnType<typeof getApiATAApproveId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiATAApproveId<TData = Awaited<ReturnType<typeof getApiATAApproveId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAApproveId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiATAApproveId<TData = Awaited<ReturnType<typeof getApiATAApproveId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiATAApproveId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiATAApproveIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiATAApproveIdResponse200 = {
  data: ApproveATARequestResponse
  status: 200
}
    
export type postApiATAApproveIdResponseComposite = postApiATAApproveIdResponse200;
    
export type postApiATAApproveIdResponse = postApiATAApproveIdResponseComposite & {
  headers: Headers;
}

export const getPostApiATAApproveIdUrl = (id: string,) => {


  

  return `/api/ATA/approve/${id}`
}

export const postApiATAApproveId = async (id: string,
    approveATARequestDto: ApproveATARequestDto, options?: RequestInit): Promise<postApiATAApproveIdResponse> => {
  
  const res = await fetch(getPostApiATAApproveIdUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      approveATARequestDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiATAApproveIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiATAApproveIdResponse
}




export const getPostApiATAApproveIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATAApproveId>>, TError,{id: string;data: ApproveATARequestDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiATAApproveId>>, TError,{id: string;data: ApproveATARequestDto}, TContext> => {

const mutationKey = ['postApiATAApproveId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiATAApproveId>>, {id: string;data: ApproveATARequestDto}> = (props) => {
          const {id,data} = props ?? {};

          return  postApiATAApproveId(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiATAApproveIdMutationResult = NonNullable<Awaited<ReturnType<typeof postApiATAApproveId>>>
    export type PostApiATAApproveIdMutationBody = ApproveATARequestDto
    export type PostApiATAApproveIdMutationError = unknown

    export const usePostApiATAApproveId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATAApproveId>>, TError,{id: string;data: ApproveATARequestDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiATAApproveId>>,
        TError,
        {id: string;data: ApproveATARequestDto},
        TContext
      > => {

      const mutationOptions = getPostApiATAApproveIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiATARejectIdResponse200 = {
  data: RejectATARequestResponse
  status: 200
}
    
export type postApiATARejectIdResponseComposite = postApiATARejectIdResponse200;
    
export type postApiATARejectIdResponse = postApiATARejectIdResponseComposite & {
  headers: Headers;
}

export const getPostApiATARejectIdUrl = (id: string,) => {


  

  return `/api/ATA/reject/${id}`
}

export const postApiATARejectId = async (id: string,
    rejectATARequestDto: RejectATARequestDto, options?: RequestInit): Promise<postApiATARejectIdResponse> => {
  
  const res = await fetch(getPostApiATARejectIdUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      rejectATARequestDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiATARejectIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiATARejectIdResponse
}




export const getPostApiATARejectIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATARejectId>>, TError,{id: string;data: RejectATARequestDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiATARejectId>>, TError,{id: string;data: RejectATARequestDto}, TContext> => {

const mutationKey = ['postApiATARejectId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiATARejectId>>, {id: string;data: RejectATARequestDto}> = (props) => {
          const {id,data} = props ?? {};

          return  postApiATARejectId(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiATARejectIdMutationResult = NonNullable<Awaited<ReturnType<typeof postApiATARejectId>>>
    export type PostApiATARejectIdMutationBody = RejectATARequestDto
    export type PostApiATARejectIdMutationError = unknown

    export const usePostApiATARejectId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiATARejectId>>, TError,{id: string;data: RejectATARequestDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiATARejectId>>,
        TError,
        {id: string;data: RejectATARequestDto},
        TContext
      > => {

      const mutationOptions = getPostApiATARejectIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiAuthRegisterResponse200 = {
  data: RegisterUserResponse
  status: 200
}

export type postApiAuthRegisterResponse400 = {
  data: ProblemDetails
  status: 400
}
    
export type postApiAuthRegisterResponseComposite = postApiAuthRegisterResponse200 | postApiAuthRegisterResponse400;
    
export type postApiAuthRegisterResponse = postApiAuthRegisterResponseComposite & {
  headers: Headers;
}

export const getPostApiAuthRegisterUrl = () => {


  

  return `/api/Auth/register`
}

export const postApiAuthRegister = async (registerRequest: RegisterRequest, options?: RequestInit): Promise<postApiAuthRegisterResponse> => {
  
  const res = await fetch(getPostApiAuthRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiAuthRegisterResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiAuthRegisterResponse
}




export const getPostApiAuthRegisterMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRegister>>, TError,{data: RegisterRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRegister>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['postApiAuthRegister'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthRegister>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthRegister(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthRegister>>>
    export type PostApiAuthRegisterMutationBody = RegisterRequest
    export type PostApiAuthRegisterMutationError = ProblemDetails

    export const usePostApiAuthRegister = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRegister>>, TError,{data: RegisterRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthRegister>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthRegisterMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiAuthLoginResponse200 = {
  data: LoginUserResponse
  status: 200
}

export type postApiAuthLoginResponse400 = {
  data: ProblemDetails
  status: 400
}
    
export type postApiAuthLoginResponseComposite = postApiAuthLoginResponse200 | postApiAuthLoginResponse400;
    
export type postApiAuthLoginResponse = postApiAuthLoginResponseComposite & {
  headers: Headers;
}

export const getPostApiAuthLoginUrl = () => {


  

  return `/api/Auth/login`
}

export const postApiAuthLogin = async (loginRequest: LoginRequest, options?: RequestInit): Promise<postApiAuthLoginResponse> => {
  
  const res = await fetch(getPostApiAuthLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiAuthLoginResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiAuthLoginResponse
}




export const getPostApiAuthLoginMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogin>>, TError,{data: LoginRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogin>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['postApiAuthLogin'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthLogin>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthLogin(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthLogin>>>
    export type PostApiAuthLoginMutationBody = LoginRequest
    export type PostApiAuthLoginMutationError = ProblemDetails

    export const usePostApiAuthLogin = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogin>>, TError,{data: LoginRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthLogin>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiAuthSendOtpResponse200 = {
  data: SendOtpResponse
  status: 200
}

export type postApiAuthSendOtpResponse400 = {
  data: ProblemDetails
  status: 400
}
    
export type postApiAuthSendOtpResponseComposite = postApiAuthSendOtpResponse200 | postApiAuthSendOtpResponse400;
    
export type postApiAuthSendOtpResponse = postApiAuthSendOtpResponseComposite & {
  headers: Headers;
}

export const getPostApiAuthSendOtpUrl = () => {


  

  return `/api/Auth/send-otp`
}

export const postApiAuthSendOtp = async (sendOtpRequest: SendOtpRequest, options?: RequestInit): Promise<postApiAuthSendOtpResponse> => {
  
  const res = await fetch(getPostApiAuthSendOtpUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sendOtpRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiAuthSendOtpResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiAuthSendOtpResponse
}




export const getPostApiAuthSendOtpMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthSendOtp>>, TError,{data: SendOtpRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthSendOtp>>, TError,{data: SendOtpRequest}, TContext> => {

const mutationKey = ['postApiAuthSendOtp'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthSendOtp>>, {data: SendOtpRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthSendOtp(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthSendOtpMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthSendOtp>>>
    export type PostApiAuthSendOtpMutationBody = SendOtpRequest
    export type PostApiAuthSendOtpMutationError = ProblemDetails

    export const usePostApiAuthSendOtp = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthSendOtp>>, TError,{data: SendOtpRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthSendOtp>>,
        TError,
        {data: SendOtpRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthSendOtpMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiAuthVerifyOtpResponse200 = {
  data: VerifyOtpCookieResponse
  status: 200
}

export type postApiAuthVerifyOtpResponse400 = {
  data: ProblemDetails
  status: 400
}
    
export type postApiAuthVerifyOtpResponseComposite = postApiAuthVerifyOtpResponse200 | postApiAuthVerifyOtpResponse400;
    
export type postApiAuthVerifyOtpResponse = postApiAuthVerifyOtpResponseComposite & {
  headers: Headers;
}

export const getPostApiAuthVerifyOtpUrl = () => {


  

  return `/api/Auth/verify-otp`
}

export const postApiAuthVerifyOtp = async (verifyOtpRequest: VerifyOtpRequest, options?: RequestInit): Promise<postApiAuthVerifyOtpResponse> => {
  
  const res = await fetch(getPostApiAuthVerifyOtpUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      verifyOtpRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiAuthVerifyOtpResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiAuthVerifyOtpResponse
}




export const getPostApiAuthVerifyOtpMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthVerifyOtp>>, TError,{data: VerifyOtpRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthVerifyOtp>>, TError,{data: VerifyOtpRequest}, TContext> => {

const mutationKey = ['postApiAuthVerifyOtp'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthVerifyOtp>>, {data: VerifyOtpRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthVerifyOtp(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthVerifyOtpMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthVerifyOtp>>>
    export type PostApiAuthVerifyOtpMutationBody = VerifyOtpRequest
    export type PostApiAuthVerifyOtpMutationError = ProblemDetails

    export const usePostApiAuthVerifyOtp = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthVerifyOtp>>, TError,{data: VerifyOtpRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthVerifyOtp>>,
        TError,
        {data: VerifyOtpRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthVerifyOtpMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiAuthMeResponse200 = {
  data: CurrentUserResponse
  status: 200
}

export type getApiAuthMeResponse400 = {
  data: ProblemDetails
  status: 400
}

export type getApiAuthMeResponse401 = {
  data: ProblemDetails
  status: 401
}
    
export type getApiAuthMeResponseComposite = getApiAuthMeResponse200 | getApiAuthMeResponse400 | getApiAuthMeResponse401;
    
export type getApiAuthMeResponse = getApiAuthMeResponseComposite & {
  headers: Headers;
}

export const getGetApiAuthMeUrl = () => {


  

  return `/api/Auth/me`
}

export const getApiAuthMe = async ( options?: RequestInit): Promise<getApiAuthMeResponse> => {
  
  const res = await fetch(getGetApiAuthMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiAuthMeResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiAuthMeResponse
}



export const getGetApiAuthMeQueryKey = () => {
    return [`/api/Auth/me`] as const;
    }

    
export const getGetApiAuthMeQueryOptions = <TData = Awaited<ReturnType<typeof getApiAuthMe>>, TError = ProblemDetails | ProblemDetails>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthMe>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiAuthMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiAuthMe>>> = ({ signal }) => getApiAuthMe({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiAuthMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiAuthMeQueryResult = NonNullable<Awaited<ReturnType<typeof getApiAuthMe>>>
export type GetApiAuthMeQueryError = ProblemDetails | ProblemDetails


export function useGetApiAuthMe<TData = Awaited<ReturnType<typeof getApiAuthMe>>, TError = ProblemDetails | ProblemDetails>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAuthMe>>,
          TError,
          Awaited<ReturnType<typeof getApiAuthMe>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiAuthMe<TData = Awaited<ReturnType<typeof getApiAuthMe>>, TError = ProblemDetails | ProblemDetails>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAuthMe>>,
          TError,
          Awaited<ReturnType<typeof getApiAuthMe>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiAuthMe<TData = Awaited<ReturnType<typeof getApiAuthMe>>, TError = ProblemDetails | ProblemDetails>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthMe>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiAuthMe<TData = Awaited<ReturnType<typeof getApiAuthMe>>, TError = ProblemDetails | ProblemDetails>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAuthMe>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiAuthMeQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiAuthLogoutResponse200 = {
  data: null
  status: 200
}
    
export type postApiAuthLogoutResponseComposite = postApiAuthLogoutResponse200;
    
export type postApiAuthLogoutResponse = postApiAuthLogoutResponseComposite & {
  headers: Headers;
}

export const getPostApiAuthLogoutUrl = () => {


  

  return `/api/Auth/logout`
}

export const postApiAuthLogout = async ( options?: RequestInit): Promise<postApiAuthLogoutResponse> => {
  
  const res = await fetch(getPostApiAuthLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiAuthLogoutResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiAuthLogoutResponse
}




export const getPostApiAuthLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogout>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogout>>, TError,void, TContext> => {

const mutationKey = ['postApiAuthLogout'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthLogout>>, void> = () => {
          

          return  postApiAuthLogout(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthLogout>>>
    
    export type PostApiAuthLogoutMutationError = unknown

    export const usePostApiAuthLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogout>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostApiAuthLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiAuthCreateSuperAdminResponse201 = {
  data: CreateSuperAdminResponse
  status: 201
}

export type postApiAuthCreateSuperAdminResponse400 = {
  data: ProblemDetails
  status: 400
}

export type postApiAuthCreateSuperAdminResponse409 = {
  data: ProblemDetails
  status: 409
}
    
export type postApiAuthCreateSuperAdminResponseComposite = postApiAuthCreateSuperAdminResponse201 | postApiAuthCreateSuperAdminResponse400 | postApiAuthCreateSuperAdminResponse409;
    
export type postApiAuthCreateSuperAdminResponse = postApiAuthCreateSuperAdminResponseComposite & {
  headers: Headers;
}

export const getPostApiAuthCreateSuperAdminUrl = () => {


  

  return `/api/Auth/create-super-admin`
}

export const postApiAuthCreateSuperAdmin = async (createSuperAdminRequest: CreateSuperAdminRequest, options?: RequestInit): Promise<postApiAuthCreateSuperAdminResponse> => {
  
  const res = await fetch(getPostApiAuthCreateSuperAdminUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createSuperAdminRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiAuthCreateSuperAdminResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiAuthCreateSuperAdminResponse
}




export const getPostApiAuthCreateSuperAdminMutationOptions = <TError = ProblemDetails | ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthCreateSuperAdmin>>, TError,{data: CreateSuperAdminRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthCreateSuperAdmin>>, TError,{data: CreateSuperAdminRequest}, TContext> => {

const mutationKey = ['postApiAuthCreateSuperAdmin'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthCreateSuperAdmin>>, {data: CreateSuperAdminRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthCreateSuperAdmin(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthCreateSuperAdminMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthCreateSuperAdmin>>>
    export type PostApiAuthCreateSuperAdminMutationBody = CreateSuperAdminRequest
    export type PostApiAuthCreateSuperAdminMutationError = ProblemDetails | ProblemDetails

    export const usePostApiAuthCreateSuperAdmin = <TError = ProblemDetails | ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthCreateSuperAdmin>>, TError,{data: CreateSuperAdminRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthCreateSuperAdmin>>,
        TError,
        {data: CreateSuperAdminRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthCreateSuperAdminMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiChatMessagesResponse200 = {
  data: ChatMessageDto[]
  status: 200
}

export type getApiChatMessagesResponse400 = {
  data: unknown
  status: 400
}
    
export type getApiChatMessagesResponseComposite = getApiChatMessagesResponse200 | getApiChatMessagesResponse400;
    
export type getApiChatMessagesResponse = getApiChatMessagesResponseComposite & {
  headers: Headers;
}

export const getGetApiChatMessagesUrl = (params?: GetApiChatMessagesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/Chat/messages?${stringifiedParams}` : `/api/Chat/messages`
}

export const getApiChatMessages = async (params?: GetApiChatMessagesParams, options?: RequestInit): Promise<getApiChatMessagesResponse> => {
  
  const res = await fetch(getGetApiChatMessagesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiChatMessagesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiChatMessagesResponse
}



export const getGetApiChatMessagesQueryKey = (params?: GetApiChatMessagesParams,) => {
    return [`/api/Chat/messages`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiChatMessagesQueryOptions = <TData = Awaited<ReturnType<typeof getApiChatMessages>>, TError = unknown>(params?: GetApiChatMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatMessages>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiChatMessagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiChatMessages>>> = ({ signal }) => getApiChatMessages(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiChatMessages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiChatMessagesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiChatMessages>>>
export type GetApiChatMessagesQueryError = unknown


export function useGetApiChatMessages<TData = Awaited<ReturnType<typeof getApiChatMessages>>, TError = unknown>(
 params: undefined |  GetApiChatMessagesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatMessages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiChatMessages>>,
          TError,
          Awaited<ReturnType<typeof getApiChatMessages>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiChatMessages<TData = Awaited<ReturnType<typeof getApiChatMessages>>, TError = unknown>(
 params?: GetApiChatMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatMessages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiChatMessages>>,
          TError,
          Awaited<ReturnType<typeof getApiChatMessages>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiChatMessages<TData = Awaited<ReturnType<typeof getApiChatMessages>>, TError = unknown>(
 params?: GetApiChatMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatMessages>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiChatMessages<TData = Awaited<ReturnType<typeof getApiChatMessages>>, TError = unknown>(
 params?: GetApiChatMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatMessages>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiChatMessagesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiChatHealthResponse200 = {
  data: unknown
  status: 200
}
    
export type getApiChatHealthResponseComposite = getApiChatHealthResponse200;
    
export type getApiChatHealthResponse = getApiChatHealthResponseComposite & {
  headers: Headers;
}

export const getGetApiChatHealthUrl = () => {


  

  return `/api/Chat/health`
}

export const getApiChatHealth = async ( options?: RequestInit): Promise<getApiChatHealthResponse> => {
  
  const res = await fetch(getGetApiChatHealthUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiChatHealthResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiChatHealthResponse
}



export const getGetApiChatHealthQueryKey = () => {
    return [`/api/Chat/health`] as const;
    }

    
export const getGetApiChatHealthQueryOptions = <TData = Awaited<ReturnType<typeof getApiChatHealth>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatHealth>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiChatHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiChatHealth>>> = ({ signal }) => getApiChatHealth({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiChatHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiChatHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getApiChatHealth>>>
export type GetApiChatHealthQueryError = unknown


export function useGetApiChatHealth<TData = Awaited<ReturnType<typeof getApiChatHealth>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiChatHealth>>,
          TError,
          Awaited<ReturnType<typeof getApiChatHealth>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiChatHealth<TData = Awaited<ReturnType<typeof getApiChatHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiChatHealth>>,
          TError,
          Awaited<ReturnType<typeof getApiChatHealth>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiChatHealth<TData = Awaited<ReturnType<typeof getApiChatHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatHealth>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiChatHealth<TData = Awaited<ReturnType<typeof getApiChatHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiChatHealth>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiChatHealthQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiFilesUploadResponse200 = {
  data: null
  status: 200
}

export type postApiFilesUploadResponse400 = {
  data: ProblemDetails
  status: 400
}
    
export type postApiFilesUploadResponseComposite = postApiFilesUploadResponse200 | postApiFilesUploadResponse400;
    
export type postApiFilesUploadResponse = postApiFilesUploadResponseComposite & {
  headers: Headers;
}

export const getPostApiFilesUploadUrl = () => {


  

  return `/api/Files/upload`
}

export const postApiFilesUpload = async (postApiFilesUploadBody: PostApiFilesUploadBody, options?: RequestInit): Promise<postApiFilesUploadResponse> => {
    const formData = new FormData();
if(postApiFilesUploadBody.file !== undefined) {
 formData.append(`file`, postApiFilesUploadBody.file)
 }

  const res = await fetch(getPostApiFilesUploadUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiFilesUploadResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiFilesUploadResponse
}




export const getPostApiFilesUploadMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesUpload>>, TError,{data: PostApiFilesUploadBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiFilesUpload>>, TError,{data: PostApiFilesUploadBody}, TContext> => {

const mutationKey = ['postApiFilesUpload'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiFilesUpload>>, {data: PostApiFilesUploadBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiFilesUpload(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiFilesUploadMutationResult = NonNullable<Awaited<ReturnType<typeof postApiFilesUpload>>>
    export type PostApiFilesUploadMutationBody = PostApiFilesUploadBody
    export type PostApiFilesUploadMutationError = ProblemDetails

    export const usePostApiFilesUpload = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesUpload>>, TError,{data: PostApiFilesUploadBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiFilesUpload>>,
        TError,
        {data: PostApiFilesUploadBody},
        TContext
      > => {

      const mutationOptions = getPostApiFilesUploadMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiFilesUploadImageResponse200 = {
  data: null
  status: 200
}

export type postApiFilesUploadImageResponse400 = {
  data: ProblemDetails
  status: 400
}
    
export type postApiFilesUploadImageResponseComposite = postApiFilesUploadImageResponse200 | postApiFilesUploadImageResponse400;
    
export type postApiFilesUploadImageResponse = postApiFilesUploadImageResponseComposite & {
  headers: Headers;
}

export const getPostApiFilesUploadImageUrl = () => {


  

  return `/api/Files/upload-image`
}

export const postApiFilesUploadImage = async (postApiFilesUploadImageBody: PostApiFilesUploadImageBody, options?: RequestInit): Promise<postApiFilesUploadImageResponse> => {
    const formData = new FormData();
if(postApiFilesUploadImageBody.file !== undefined) {
 formData.append(`file`, postApiFilesUploadImageBody.file)
 }

  const res = await fetch(getPostApiFilesUploadImageUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiFilesUploadImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiFilesUploadImageResponse
}




export const getPostApiFilesUploadImageMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesUploadImage>>, TError,{data: PostApiFilesUploadImageBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiFilesUploadImage>>, TError,{data: PostApiFilesUploadImageBody}, TContext> => {

const mutationKey = ['postApiFilesUploadImage'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiFilesUploadImage>>, {data: PostApiFilesUploadImageBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiFilesUploadImage(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiFilesUploadImageMutationResult = NonNullable<Awaited<ReturnType<typeof postApiFilesUploadImage>>>
    export type PostApiFilesUploadImageMutationBody = PostApiFilesUploadImageBody
    export type PostApiFilesUploadImageMutationError = ProblemDetails

    export const usePostApiFilesUploadImage = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesUploadImage>>, TError,{data: PostApiFilesUploadImageBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiFilesUploadImage>>,
        TError,
        {data: PostApiFilesUploadImageBody},
        TContext
      > => {

      const mutationOptions = getPostApiFilesUploadImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiFilesImagesLatestResponse200 = {
  data: null
  status: 200
}

export type getApiFilesImagesLatestResponse400 = {
  data: ProblemDetails
  status: 400
}
    
export type getApiFilesImagesLatestResponseComposite = getApiFilesImagesLatestResponse200 | getApiFilesImagesLatestResponse400;
    
export type getApiFilesImagesLatestResponse = getApiFilesImagesLatestResponseComposite & {
  headers: Headers;
}

export const getGetApiFilesImagesLatestUrl = (params?: GetApiFilesImagesLatestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/Files/images/latest?${stringifiedParams}` : `/api/Files/images/latest`
}

export const getApiFilesImagesLatest = async (params?: GetApiFilesImagesLatestParams, options?: RequestInit): Promise<getApiFilesImagesLatestResponse> => {
  
  const res = await fetch(getGetApiFilesImagesLatestUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiFilesImagesLatestResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiFilesImagesLatestResponse
}



export const getGetApiFilesImagesLatestQueryKey = (params?: GetApiFilesImagesLatestParams,) => {
    return [`/api/Files/images/latest`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiFilesImagesLatestQueryOptions = <TData = Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError = ProblemDetails>(params?: GetApiFilesImagesLatestParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiFilesImagesLatestQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiFilesImagesLatest>>> = ({ signal }) => getApiFilesImagesLatest(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiFilesImagesLatestQueryResult = NonNullable<Awaited<ReturnType<typeof getApiFilesImagesLatest>>>
export type GetApiFilesImagesLatestQueryError = ProblemDetails


export function useGetApiFilesImagesLatest<TData = Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError = ProblemDetails>(
 params: undefined |  GetApiFilesImagesLatestParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFilesImagesLatest>>,
          TError,
          Awaited<ReturnType<typeof getApiFilesImagesLatest>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFilesImagesLatest<TData = Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError = ProblemDetails>(
 params?: GetApiFilesImagesLatestParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFilesImagesLatest>>,
          TError,
          Awaited<ReturnType<typeof getApiFilesImagesLatest>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFilesImagesLatest<TData = Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError = ProblemDetails>(
 params?: GetApiFilesImagesLatestParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiFilesImagesLatest<TData = Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError = ProblemDetails>(
 params?: GetApiFilesImagesLatestParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesImagesLatest>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiFilesImagesLatestQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiFilesInfoFilePathResponse200 = {
  data: null
  status: 200
}

export type getApiFilesInfoFilePathResponse404 = {
  data: ProblemDetails
  status: 404
}
    
export type getApiFilesInfoFilePathResponseComposite = getApiFilesInfoFilePathResponse200 | getApiFilesInfoFilePathResponse404;
    
export type getApiFilesInfoFilePathResponse = getApiFilesInfoFilePathResponseComposite & {
  headers: Headers;
}

export const getGetApiFilesInfoFilePathUrl = (filePath: string,) => {


  

  return `/api/Files/info/${filePath}`
}

export const getApiFilesInfoFilePath = async (filePath: string, options?: RequestInit): Promise<getApiFilesInfoFilePathResponse> => {
  
  const res = await fetch(getGetApiFilesInfoFilePathUrl(filePath),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiFilesInfoFilePathResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiFilesInfoFilePathResponse
}



export const getGetApiFilesInfoFilePathQueryKey = (filePath?: string,) => {
    return [`/api/Files/info/${filePath}`] as const;
    }

    
export const getGetApiFilesInfoFilePathQueryOptions = <TData = Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError = ProblemDetails>(filePath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiFilesInfoFilePathQueryKey(filePath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiFilesInfoFilePath>>> = ({ signal }) => getApiFilesInfoFilePath(filePath, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(filePath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiFilesInfoFilePathQueryResult = NonNullable<Awaited<ReturnType<typeof getApiFilesInfoFilePath>>>
export type GetApiFilesInfoFilePathQueryError = ProblemDetails


export function useGetApiFilesInfoFilePath<TData = Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError = ProblemDetails>(
 filePath: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFilesInfoFilePath>>,
          TError,
          Awaited<ReturnType<typeof getApiFilesInfoFilePath>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFilesInfoFilePath<TData = Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError = ProblemDetails>(
 filePath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFilesInfoFilePath>>,
          TError,
          Awaited<ReturnType<typeof getApiFilesInfoFilePath>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFilesInfoFilePath<TData = Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError = ProblemDetails>(
 filePath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiFilesInfoFilePath<TData = Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError = ProblemDetails>(
 filePath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesInfoFilePath>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiFilesInfoFilePathQueryOptions(filePath,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiHabitsResponse200 = {
  data: HabitForDayDto[]
  status: 200
}
    
export type getApiHabitsResponseComposite = getApiHabitsResponse200;
    
export type getApiHabitsResponse = getApiHabitsResponseComposite & {
  headers: Headers;
}

export const getGetApiHabitsUrl = (params?: GetApiHabitsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/Habits?${stringifiedParams}` : `/api/Habits`
}

export const getApiHabits = async (params?: GetApiHabitsParams, options?: RequestInit): Promise<getApiHabitsResponse> => {
  
  const res = await fetch(getGetApiHabitsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiHabitsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiHabitsResponse
}



export const getGetApiHabitsQueryKey = (params?: GetApiHabitsParams,) => {
    return [`/api/Habits`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiHabitsQueryOptions = <TData = Awaited<ReturnType<typeof getApiHabits>>, TError = unknown>(params?: GetApiHabitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabits>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiHabitsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiHabits>>> = ({ signal }) => getApiHabits(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiHabits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiHabitsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiHabits>>>
export type GetApiHabitsQueryError = unknown


export function useGetApiHabits<TData = Awaited<ReturnType<typeof getApiHabits>>, TError = unknown>(
 params: undefined |  GetApiHabitsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiHabits>>,
          TError,
          Awaited<ReturnType<typeof getApiHabits>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiHabits<TData = Awaited<ReturnType<typeof getApiHabits>>, TError = unknown>(
 params?: GetApiHabitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiHabits>>,
          TError,
          Awaited<ReturnType<typeof getApiHabits>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiHabits<TData = Awaited<ReturnType<typeof getApiHabits>>, TError = unknown>(
 params?: GetApiHabitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabits>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiHabits<TData = Awaited<ReturnType<typeof getApiHabits>>, TError = unknown>(
 params?: GetApiHabitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabits>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiHabitsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiHabitsResponse200 = {
  data: CreateHabitResponse
  status: 200
}
    
export type postApiHabitsResponseComposite = postApiHabitsResponse200;
    
export type postApiHabitsResponse = postApiHabitsResponseComposite & {
  headers: Headers;
}

export const getPostApiHabitsUrl = () => {


  

  return `/api/Habits`
}

export const postApiHabits = async (createHabitCommand: CreateHabitCommand, options?: RequestInit): Promise<postApiHabitsResponse> => {
  
  const res = await fetch(getPostApiHabitsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createHabitCommand,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiHabitsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiHabitsResponse
}




export const getPostApiHabitsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiHabits>>, TError,{data: CreateHabitCommand}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiHabits>>, TError,{data: CreateHabitCommand}, TContext> => {

const mutationKey = ['postApiHabits'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiHabits>>, {data: CreateHabitCommand}> = (props) => {
          const {data} = props ?? {};

          return  postApiHabits(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiHabitsMutationResult = NonNullable<Awaited<ReturnType<typeof postApiHabits>>>
    export type PostApiHabitsMutationBody = CreateHabitCommand
    export type PostApiHabitsMutationError = unknown

    export const usePostApiHabits = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiHabits>>, TError,{data: CreateHabitCommand}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiHabits>>,
        TError,
        {data: CreateHabitCommand},
        TContext
      > => {

      const mutationOptions = getPostApiHabitsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiHabitsTodayResponse200 = {
  data: HabitForDayDto[]
  status: 200
}
    
export type getApiHabitsTodayResponseComposite = getApiHabitsTodayResponse200;
    
export type getApiHabitsTodayResponse = getApiHabitsTodayResponseComposite & {
  headers: Headers;
}

export const getGetApiHabitsTodayUrl = () => {


  

  return `/api/Habits/today`
}

export const getApiHabitsToday = async ( options?: RequestInit): Promise<getApiHabitsTodayResponse> => {
  
  const res = await fetch(getGetApiHabitsTodayUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiHabitsTodayResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiHabitsTodayResponse
}



export const getGetApiHabitsTodayQueryKey = () => {
    return [`/api/Habits/today`] as const;
    }

    
export const getGetApiHabitsTodayQueryOptions = <TData = Awaited<ReturnType<typeof getApiHabitsToday>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabitsToday>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiHabitsTodayQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiHabitsToday>>> = ({ signal }) => getApiHabitsToday({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiHabitsToday>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiHabitsTodayQueryResult = NonNullable<Awaited<ReturnType<typeof getApiHabitsToday>>>
export type GetApiHabitsTodayQueryError = unknown


export function useGetApiHabitsToday<TData = Awaited<ReturnType<typeof getApiHabitsToday>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabitsToday>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiHabitsToday>>,
          TError,
          Awaited<ReturnType<typeof getApiHabitsToday>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiHabitsToday<TData = Awaited<ReturnType<typeof getApiHabitsToday>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabitsToday>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiHabitsToday>>,
          TError,
          Awaited<ReturnType<typeof getApiHabitsToday>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiHabitsToday<TData = Awaited<ReturnType<typeof getApiHabitsToday>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabitsToday>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiHabitsToday<TData = Awaited<ReturnType<typeof getApiHabitsToday>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiHabitsToday>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiHabitsTodayQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiHabitsCheckinResponse200 = {
  data: CheckInHabitResponse
  status: 200
}
    
export type postApiHabitsCheckinResponseComposite = postApiHabitsCheckinResponse200;
    
export type postApiHabitsCheckinResponse = postApiHabitsCheckinResponseComposite & {
  headers: Headers;
}

export const getPostApiHabitsCheckinUrl = () => {


  

  return `/api/Habits/checkin`
}

export const postApiHabitsCheckin = async (checkInHabitCommand: CheckInHabitCommand, options?: RequestInit): Promise<postApiHabitsCheckinResponse> => {
  
  const res = await fetch(getPostApiHabitsCheckinUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      checkInHabitCommand,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiHabitsCheckinResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiHabitsCheckinResponse
}




export const getPostApiHabitsCheckinMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiHabitsCheckin>>, TError,{data: CheckInHabitCommand}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiHabitsCheckin>>, TError,{data: CheckInHabitCommand}, TContext> => {

const mutationKey = ['postApiHabitsCheckin'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiHabitsCheckin>>, {data: CheckInHabitCommand}> = (props) => {
          const {data} = props ?? {};

          return  postApiHabitsCheckin(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiHabitsCheckinMutationResult = NonNullable<Awaited<ReturnType<typeof postApiHabitsCheckin>>>
    export type PostApiHabitsCheckinMutationBody = CheckInHabitCommand
    export type PostApiHabitsCheckinMutationError = unknown

    export const usePostApiHabitsCheckin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiHabitsCheckin>>, TError,{data: CheckInHabitCommand}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiHabitsCheckin>>,
        TError,
        {data: CheckInHabitCommand},
        TContext
      > => {

      const mutationOptions = getPostApiHabitsCheckinMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type deleteApiHabitsHabitIdResponse200 = {
  data: RemoveHabitResponse
  status: 200
}
    
export type deleteApiHabitsHabitIdResponseComposite = deleteApiHabitsHabitIdResponse200;
    
export type deleteApiHabitsHabitIdResponse = deleteApiHabitsHabitIdResponseComposite & {
  headers: Headers;
}

export const getDeleteApiHabitsHabitIdUrl = (habitId: string,) => {


  

  return `/api/Habits/${habitId}`
}

export const deleteApiHabitsHabitId = async (habitId: string, options?: RequestInit): Promise<deleteApiHabitsHabitIdResponse> => {
  
  const res = await fetch(getDeleteApiHabitsHabitIdUrl(habitId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteApiHabitsHabitIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteApiHabitsHabitIdResponse
}




export const getDeleteApiHabitsHabitIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiHabitsHabitId>>, TError,{habitId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiHabitsHabitId>>, TError,{habitId: string}, TContext> => {

const mutationKey = ['deleteApiHabitsHabitId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiHabitsHabitId>>, {habitId: string}> = (props) => {
          const {habitId} = props ?? {};

          return  deleteApiHabitsHabitId(habitId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiHabitsHabitIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiHabitsHabitId>>>
    
    export type DeleteApiHabitsHabitIdMutationError = unknown

    export const useDeleteApiHabitsHabitId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiHabitsHabitId>>, TError,{habitId: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiHabitsHabitId>>,
        TError,
        {habitId: string},
        TContext
      > => {

      const mutationOptions = getDeleteApiHabitsHabitIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiKanbanBoardsResponse200 = {
  data: KanbanBoardSummaryDto[]
  status: 200
}
    
export type getApiKanbanBoardsResponseComposite = getApiKanbanBoardsResponse200;
    
export type getApiKanbanBoardsResponse = getApiKanbanBoardsResponseComposite & {
  headers: Headers;
}

export const getGetApiKanbanBoardsUrl = () => {


  

  return `/api/Kanban/boards`
}

export const getApiKanbanBoards = async ( options?: RequestInit): Promise<getApiKanbanBoardsResponse> => {
  
  const res = await fetch(getGetApiKanbanBoardsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiKanbanBoardsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiKanbanBoardsResponse
}



export const getGetApiKanbanBoardsQueryKey = () => {
    return [`/api/Kanban/boards`] as const;
    }

    
export const getGetApiKanbanBoardsQueryOptions = <TData = Awaited<ReturnType<typeof getApiKanbanBoards>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoards>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiKanbanBoardsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKanbanBoards>>> = ({ signal }) => getApiKanbanBoards({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoards>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiKanbanBoardsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKanbanBoards>>>
export type GetApiKanbanBoardsQueryError = unknown


export function useGetApiKanbanBoards<TData = Awaited<ReturnType<typeof getApiKanbanBoards>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoards>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanBoards>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanBoards>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanBoards<TData = Awaited<ReturnType<typeof getApiKanbanBoards>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoards>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanBoards>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanBoards>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanBoards<TData = Awaited<ReturnType<typeof getApiKanbanBoards>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoards>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiKanbanBoards<TData = Awaited<ReturnType<typeof getApiKanbanBoards>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoards>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiKanbanBoardsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiKanbanBoardsResponse200 = {
  data: CreateBoardResponse
  status: 200
}
    
export type postApiKanbanBoardsResponseComposite = postApiKanbanBoardsResponse200;
    
export type postApiKanbanBoardsResponse = postApiKanbanBoardsResponseComposite & {
  headers: Headers;
}

export const getPostApiKanbanBoardsUrl = () => {


  

  return `/api/Kanban/boards`
}

export const postApiKanbanBoards = async (createBoardRequest: CreateBoardRequest, options?: RequestInit): Promise<postApiKanbanBoardsResponse> => {
  
  const res = await fetch(getPostApiKanbanBoardsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createBoardRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiKanbanBoardsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiKanbanBoardsResponse
}




export const getPostApiKanbanBoardsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoards>>, TError,{data: CreateBoardRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoards>>, TError,{data: CreateBoardRequest}, TContext> => {

const mutationKey = ['postApiKanbanBoards'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiKanbanBoards>>, {data: CreateBoardRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiKanbanBoards(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiKanbanBoardsMutationResult = NonNullable<Awaited<ReturnType<typeof postApiKanbanBoards>>>
    export type PostApiKanbanBoardsMutationBody = CreateBoardRequest
    export type PostApiKanbanBoardsMutationError = unknown

    export const usePostApiKanbanBoards = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoards>>, TError,{data: CreateBoardRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiKanbanBoards>>,
        TError,
        {data: CreateBoardRequest},
        TContext
      > => {

      const mutationOptions = getPostApiKanbanBoardsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiKanbanBoardsBoardIdResponse200 = {
  data: KanbanBoardDto
  status: 200
}
    
export type getApiKanbanBoardsBoardIdResponseComposite = getApiKanbanBoardsBoardIdResponse200;
    
export type getApiKanbanBoardsBoardIdResponse = getApiKanbanBoardsBoardIdResponseComposite & {
  headers: Headers;
}

export const getGetApiKanbanBoardsBoardIdUrl = (boardId: string,) => {


  

  return `/api/Kanban/boards/${boardId}`
}

export const getApiKanbanBoardsBoardId = async (boardId: string, options?: RequestInit): Promise<getApiKanbanBoardsBoardIdResponse> => {
  
  const res = await fetch(getGetApiKanbanBoardsBoardIdUrl(boardId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiKanbanBoardsBoardIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiKanbanBoardsBoardIdResponse
}



export const getGetApiKanbanBoardsBoardIdQueryKey = (boardId?: string,) => {
    return [`/api/Kanban/boards/${boardId}`] as const;
    }

    
export const getGetApiKanbanBoardsBoardIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError = unknown>(boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiKanbanBoardsBoardIdQueryKey(boardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>> = ({ signal }) => getApiKanbanBoardsBoardId(boardId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(boardId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiKanbanBoardsBoardIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>>
export type GetApiKanbanBoardsBoardIdQueryError = unknown


export function useGetApiKanbanBoardsBoardId<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError = unknown>(
 boardId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanBoardsBoardId<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanBoardsBoardId<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiKanbanBoardsBoardId<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiKanbanBoardsBoardIdQueryOptions(boardId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiKanbanBoardsBoardIdTasksResponse200 = {
  data: CreateTaskResponse
  status: 200
}
    
export type postApiKanbanBoardsBoardIdTasksResponseComposite = postApiKanbanBoardsBoardIdTasksResponse200;
    
export type postApiKanbanBoardsBoardIdTasksResponse = postApiKanbanBoardsBoardIdTasksResponseComposite & {
  headers: Headers;
}

export const getPostApiKanbanBoardsBoardIdTasksUrl = (boardId: string,) => {


  

  return `/api/Kanban/boards/${boardId}/tasks`
}

export const postApiKanbanBoardsBoardIdTasks = async (boardId: string,
    createTaskRequest: CreateTaskRequest, options?: RequestInit): Promise<postApiKanbanBoardsBoardIdTasksResponse> => {
  
  const res = await fetch(getPostApiKanbanBoardsBoardIdTasksUrl(boardId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTaskRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiKanbanBoardsBoardIdTasksResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiKanbanBoardsBoardIdTasksResponse
}




export const getPostApiKanbanBoardsBoardIdTasksMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasks>>, TError,{boardId: string;data: CreateTaskRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasks>>, TError,{boardId: string;data: CreateTaskRequest}, TContext> => {

const mutationKey = ['postApiKanbanBoardsBoardIdTasks'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasks>>, {boardId: string;data: CreateTaskRequest}> = (props) => {
          const {boardId,data} = props ?? {};

          return  postApiKanbanBoardsBoardIdTasks(boardId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiKanbanBoardsBoardIdTasksMutationResult = NonNullable<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasks>>>
    export type PostApiKanbanBoardsBoardIdTasksMutationBody = CreateTaskRequest
    export type PostApiKanbanBoardsBoardIdTasksMutationError = unknown

    export const usePostApiKanbanBoardsBoardIdTasks = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasks>>, TError,{boardId: string;data: CreateTaskRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasks>>,
        TError,
        {boardId: string;data: CreateTaskRequest},
        TContext
      > => {

      const mutationOptions = getPostApiKanbanBoardsBoardIdTasksMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type putApiKanbanBoardsBoardIdTasksTaskIdMoveResponse200 = {
  data: MoveTaskResponse
  status: 200
}
    
export type putApiKanbanBoardsBoardIdTasksTaskIdMoveResponseComposite = putApiKanbanBoardsBoardIdTasksTaskIdMoveResponse200;
    
export type putApiKanbanBoardsBoardIdTasksTaskIdMoveResponse = putApiKanbanBoardsBoardIdTasksTaskIdMoveResponseComposite & {
  headers: Headers;
}

export const getPutApiKanbanBoardsBoardIdTasksTaskIdMoveUrl = (boardId: string,
    taskId: string,) => {


  

  return `/api/Kanban/boards/${boardId}/tasks/${taskId}/move`
}

export const putApiKanbanBoardsBoardIdTasksTaskIdMove = async (boardId: string,
    taskId: string,
    moveTaskRequest: MoveTaskRequest, options?: RequestInit): Promise<putApiKanbanBoardsBoardIdTasksTaskIdMoveResponse> => {
  
  const res = await fetch(getPutApiKanbanBoardsBoardIdTasksTaskIdMoveUrl(boardId,taskId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moveTaskRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putApiKanbanBoardsBoardIdTasksTaskIdMoveResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putApiKanbanBoardsBoardIdTasksTaskIdMoveResponse
}




export const getPutApiKanbanBoardsBoardIdTasksTaskIdMoveMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdMove>>, TError,{boardId: string;taskId: string;data: MoveTaskRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdMove>>, TError,{boardId: string;taskId: string;data: MoveTaskRequest}, TContext> => {

const mutationKey = ['putApiKanbanBoardsBoardIdTasksTaskIdMove'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdMove>>, {boardId: string;taskId: string;data: MoveTaskRequest}> = (props) => {
          const {boardId,taskId,data} = props ?? {};

          return  putApiKanbanBoardsBoardIdTasksTaskIdMove(boardId,taskId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiKanbanBoardsBoardIdTasksTaskIdMoveMutationResult = NonNullable<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdMove>>>
    export type PutApiKanbanBoardsBoardIdTasksTaskIdMoveMutationBody = MoveTaskRequest
    export type PutApiKanbanBoardsBoardIdTasksTaskIdMoveMutationError = unknown

    export const usePutApiKanbanBoardsBoardIdTasksTaskIdMove = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdMove>>, TError,{boardId: string;taskId: string;data: MoveTaskRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdMove>>,
        TError,
        {boardId: string;taskId: string;data: MoveTaskRequest},
        TContext
      > => {

      const mutationOptions = getPutApiKanbanBoardsBoardIdTasksTaskIdMoveMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiKanbanBoardsBoardIdTasksTaskIdSubtasksResponse200 = {
  data: AddSubtaskResponse
  status: 200
}
    
export type postApiKanbanBoardsBoardIdTasksTaskIdSubtasksResponseComposite = postApiKanbanBoardsBoardIdTasksTaskIdSubtasksResponse200;
    
export type postApiKanbanBoardsBoardIdTasksTaskIdSubtasksResponse = postApiKanbanBoardsBoardIdTasksTaskIdSubtasksResponseComposite & {
  headers: Headers;
}

export const getPostApiKanbanBoardsBoardIdTasksTaskIdSubtasksUrl = (boardId: string,
    taskId: string,) => {


  

  return `/api/Kanban/boards/${boardId}/tasks/${taskId}/subtasks`
}

export const postApiKanbanBoardsBoardIdTasksTaskIdSubtasks = async (boardId: string,
    taskId: string,
    addSubtaskRequest: AddSubtaskRequest, options?: RequestInit): Promise<postApiKanbanBoardsBoardIdTasksTaskIdSubtasksResponse> => {
  
  const res = await fetch(getPostApiKanbanBoardsBoardIdTasksTaskIdSubtasksUrl(boardId,taskId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addSubtaskRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiKanbanBoardsBoardIdTasksTaskIdSubtasksResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiKanbanBoardsBoardIdTasksTaskIdSubtasksResponse
}




export const getPostApiKanbanBoardsBoardIdTasksTaskIdSubtasksMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasksTaskIdSubtasks>>, TError,{boardId: string;taskId: string;data: AddSubtaskRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasksTaskIdSubtasks>>, TError,{boardId: string;taskId: string;data: AddSubtaskRequest}, TContext> => {

const mutationKey = ['postApiKanbanBoardsBoardIdTasksTaskIdSubtasks'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasksTaskIdSubtasks>>, {boardId: string;taskId: string;data: AddSubtaskRequest}> = (props) => {
          const {boardId,taskId,data} = props ?? {};

          return  postApiKanbanBoardsBoardIdTasksTaskIdSubtasks(boardId,taskId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiKanbanBoardsBoardIdTasksTaskIdSubtasksMutationResult = NonNullable<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasksTaskIdSubtasks>>>
    export type PostApiKanbanBoardsBoardIdTasksTaskIdSubtasksMutationBody = AddSubtaskRequest
    export type PostApiKanbanBoardsBoardIdTasksTaskIdSubtasksMutationError = unknown

    export const usePostApiKanbanBoardsBoardIdTasksTaskIdSubtasks = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasksTaskIdSubtasks>>, TError,{boardId: string;taskId: string;data: AddSubtaskRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiKanbanBoardsBoardIdTasksTaskIdSubtasks>>,
        TError,
        {boardId: string;taskId: string;data: AddSubtaskRequest},
        TContext
      > => {

      const mutationOptions = getPostApiKanbanBoardsBoardIdTasksTaskIdSubtasksMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleResponse200 = {
  data: ToggleSubtaskResponse
  status: 200
}
    
export type putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleResponseComposite = putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleResponse200;
    
export type putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleResponse = putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleResponseComposite & {
  headers: Headers;
}

export const getPutApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleUrl = (boardId: string,
    taskId: string,
    subtaskIndex: number,) => {


  

  return `/api/Kanban/boards/${boardId}/tasks/${taskId}/subtasks/${subtaskIndex}/toggle`
}

export const putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle = async (boardId: string,
    taskId: string,
    subtaskIndex: number, options?: RequestInit): Promise<putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleResponse> => {
  
  const res = await fetch(getPutApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleUrl(boardId,taskId,subtaskIndex),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleResponse
}




export const getPutApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle>>, TError,{boardId: string;taskId: string;subtaskIndex: number}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle>>, TError,{boardId: string;taskId: string;subtaskIndex: number}, TContext> => {

const mutationKey = ['putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle>>, {boardId: string;taskId: string;subtaskIndex: number}> = (props) => {
          const {boardId,taskId,subtaskIndex} = props ?? {};

          return  putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle(boardId,taskId,subtaskIndex,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleMutationResult = NonNullable<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle>>>
    
    export type PutApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleMutationError = unknown

    export const usePutApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle>>, TError,{boardId: string;taskId: string;subtaskIndex: number}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggle>>,
        TError,
        {boardId: string;taskId: string;subtaskIndex: number},
        TContext
      > => {

      const mutationOptions = getPutApiKanbanBoardsBoardIdTasksTaskIdSubtasksSubtaskIndexToggleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiKanbanChatStreamResponse200 = {
  data: null
  status: 200
}
    
export type getApiKanbanChatStreamResponseComposite = getApiKanbanChatStreamResponse200;
    
export type getApiKanbanChatStreamResponse = getApiKanbanChatStreamResponseComposite & {
  headers: Headers;
}

export const getGetApiKanbanChatStreamUrl = (params?: GetApiKanbanChatStreamParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/kanban/chat/stream?${stringifiedParams}` : `/api/kanban/chat/stream`
}

export const getApiKanbanChatStream = async (params?: GetApiKanbanChatStreamParams, options?: RequestInit): Promise<getApiKanbanChatStreamResponse> => {
  
  const res = await fetch(getGetApiKanbanChatStreamUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiKanbanChatStreamResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiKanbanChatStreamResponse
}



export const getGetApiKanbanChatStreamQueryKey = (params?: GetApiKanbanChatStreamParams,) => {
    return [`/api/kanban/chat/stream`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiKanbanChatStreamQueryOptions = <TData = Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError = unknown>(params?: GetApiKanbanChatStreamParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiKanbanChatStreamQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKanbanChatStream>>> = ({ signal }) => getApiKanbanChatStream(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiKanbanChatStreamQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKanbanChatStream>>>
export type GetApiKanbanChatStreamQueryError = unknown


export function useGetApiKanbanChatStream<TData = Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError = unknown>(
 params: undefined |  GetApiKanbanChatStreamParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanChatStream>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanChatStream>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanChatStream<TData = Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError = unknown>(
 params?: GetApiKanbanChatStreamParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanChatStream>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanChatStream>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanChatStream<TData = Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError = unknown>(
 params?: GetApiKanbanChatStreamParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiKanbanChatStream<TData = Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError = unknown>(
 params?: GetApiKanbanChatStreamParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatStream>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiKanbanChatStreamQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiKanbanChatSessionsSessionIdMessagesResponse200 = {
  data: GetChatSessionMessagesResponse
  status: 200
}
    
export type getApiKanbanChatSessionsSessionIdMessagesResponseComposite = getApiKanbanChatSessionsSessionIdMessagesResponse200;
    
export type getApiKanbanChatSessionsSessionIdMessagesResponse = getApiKanbanChatSessionsSessionIdMessagesResponseComposite & {
  headers: Headers;
}

export const getGetApiKanbanChatSessionsSessionIdMessagesUrl = (sessionId: string,) => {


  

  return `/api/kanban/chat/sessions/${sessionId}/messages`
}

export const getApiKanbanChatSessionsSessionIdMessages = async (sessionId: string, options?: RequestInit): Promise<getApiKanbanChatSessionsSessionIdMessagesResponse> => {
  
  const res = await fetch(getGetApiKanbanChatSessionsSessionIdMessagesUrl(sessionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiKanbanChatSessionsSessionIdMessagesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiKanbanChatSessionsSessionIdMessagesResponse
}



export const getGetApiKanbanChatSessionsSessionIdMessagesQueryKey = (sessionId?: string,) => {
    return [`/api/kanban/chat/sessions/${sessionId}/messages`] as const;
    }

    
export const getGetApiKanbanChatSessionsSessionIdMessagesQueryOptions = <TData = Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError = unknown>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiKanbanChatSessionsSessionIdMessagesQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>> = ({ signal }) => getApiKanbanChatSessionsSessionIdMessages(sessionId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiKanbanChatSessionsSessionIdMessagesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>>
export type GetApiKanbanChatSessionsSessionIdMessagesQueryError = unknown


export function useGetApiKanbanChatSessionsSessionIdMessages<TData = Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError = unknown>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanChatSessionsSessionIdMessages<TData = Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError = unknown>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanChatSessionsSessionIdMessages<TData = Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError = unknown>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiKanbanChatSessionsSessionIdMessages<TData = Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError = unknown>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanChatSessionsSessionIdMessages>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiKanbanChatSessionsSessionIdMessagesQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiKanbanChatSessionsResponse200 = {
  data: CreateChatSessionResponse
  status: 200
}
    
export type postApiKanbanChatSessionsResponseComposite = postApiKanbanChatSessionsResponse200;
    
export type postApiKanbanChatSessionsResponse = postApiKanbanChatSessionsResponseComposite & {
  headers: Headers;
}

export const getPostApiKanbanChatSessionsUrl = () => {


  

  return `/api/kanban/chat/sessions`
}

export const postApiKanbanChatSessions = async (createChatSessionRequest: CreateChatSessionRequest, options?: RequestInit): Promise<postApiKanbanChatSessionsResponse> => {
  
  const res = await fetch(getPostApiKanbanChatSessionsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createChatSessionRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiKanbanChatSessionsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiKanbanChatSessionsResponse
}




export const getPostApiKanbanChatSessionsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanChatSessions>>, TError,{data: CreateChatSessionRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanChatSessions>>, TError,{data: CreateChatSessionRequest}, TContext> => {

const mutationKey = ['postApiKanbanChatSessions'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiKanbanChatSessions>>, {data: CreateChatSessionRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiKanbanChatSessions(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiKanbanChatSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof postApiKanbanChatSessions>>>
    export type PostApiKanbanChatSessionsMutationBody = CreateChatSessionRequest
    export type PostApiKanbanChatSessionsMutationError = unknown

    export const usePostApiKanbanChatSessions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiKanbanChatSessions>>, TError,{data: CreateChatSessionRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiKanbanChatSessions>>,
        TError,
        {data: CreateChatSessionRequest},
        TContext
      > => {

      const mutationOptions = getPostApiKanbanChatSessionsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiKanbanBoardsBoardIdCurrentSessionResponse200 = {
  data: GetCurrentChatSessionResponse
  status: 200
}
    
export type getApiKanbanBoardsBoardIdCurrentSessionResponseComposite = getApiKanbanBoardsBoardIdCurrentSessionResponse200;
    
export type getApiKanbanBoardsBoardIdCurrentSessionResponse = getApiKanbanBoardsBoardIdCurrentSessionResponseComposite & {
  headers: Headers;
}

export const getGetApiKanbanBoardsBoardIdCurrentSessionUrl = (boardId: string,) => {


  

  return `/api/kanban/boards/${boardId}/current-session`
}

export const getApiKanbanBoardsBoardIdCurrentSession = async (boardId: string, options?: RequestInit): Promise<getApiKanbanBoardsBoardIdCurrentSessionResponse> => {
  
  const res = await fetch(getGetApiKanbanBoardsBoardIdCurrentSessionUrl(boardId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiKanbanBoardsBoardIdCurrentSessionResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiKanbanBoardsBoardIdCurrentSessionResponse
}



export const getGetApiKanbanBoardsBoardIdCurrentSessionQueryKey = (boardId?: string,) => {
    return [`/api/kanban/boards/${boardId}/current-session`] as const;
    }

    
export const getGetApiKanbanBoardsBoardIdCurrentSessionQueryOptions = <TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError = unknown>(boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiKanbanBoardsBoardIdCurrentSessionQueryKey(boardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>> = ({ signal }) => getApiKanbanBoardsBoardIdCurrentSession(boardId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(boardId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiKanbanBoardsBoardIdCurrentSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>>
export type GetApiKanbanBoardsBoardIdCurrentSessionQueryError = unknown


export function useGetApiKanbanBoardsBoardIdCurrentSession<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError = unknown>(
 boardId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanBoardsBoardIdCurrentSession<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanBoardsBoardIdCurrentSession<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiKanbanBoardsBoardIdCurrentSession<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdCurrentSession>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiKanbanBoardsBoardIdCurrentSessionQueryOptions(boardId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiKanbanBoardsBoardIdSessionsResponse200 = {
  data: GetBoardChatSessionsResponse
  status: 200
}
    
export type getApiKanbanBoardsBoardIdSessionsResponseComposite = getApiKanbanBoardsBoardIdSessionsResponse200;
    
export type getApiKanbanBoardsBoardIdSessionsResponse = getApiKanbanBoardsBoardIdSessionsResponseComposite & {
  headers: Headers;
}

export const getGetApiKanbanBoardsBoardIdSessionsUrl = (boardId: string,) => {


  

  return `/api/kanban/boards/${boardId}/sessions`
}

export const getApiKanbanBoardsBoardIdSessions = async (boardId: string, options?: RequestInit): Promise<getApiKanbanBoardsBoardIdSessionsResponse> => {
  
  const res = await fetch(getGetApiKanbanBoardsBoardIdSessionsUrl(boardId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiKanbanBoardsBoardIdSessionsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiKanbanBoardsBoardIdSessionsResponse
}



export const getGetApiKanbanBoardsBoardIdSessionsQueryKey = (boardId?: string,) => {
    return [`/api/kanban/boards/${boardId}/sessions`] as const;
    }

    
export const getGetApiKanbanBoardsBoardIdSessionsQueryOptions = <TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError = unknown>(boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiKanbanBoardsBoardIdSessionsQueryKey(boardId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>> = ({ signal }) => getApiKanbanBoardsBoardIdSessions(boardId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(boardId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiKanbanBoardsBoardIdSessionsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>>
export type GetApiKanbanBoardsBoardIdSessionsQueryError = unknown


export function useGetApiKanbanBoardsBoardIdSessions<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError = unknown>(
 boardId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanBoardsBoardIdSessions<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>,
          TError,
          Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiKanbanBoardsBoardIdSessions<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiKanbanBoardsBoardIdSessions<TData = Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError = unknown>(
 boardId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKanbanBoardsBoardIdSessions>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiKanbanBoardsBoardIdSessionsQueryOptions(boardId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiNewsletterSubscribeResponse200 = {
  data: SaveEmailToNewsletterResponse
  status: 200
}

export type postApiNewsletterSubscribeResponse400 = {
  data: ProblemDetails
  status: 400
}
    
export type postApiNewsletterSubscribeResponseComposite = postApiNewsletterSubscribeResponse200 | postApiNewsletterSubscribeResponse400;
    
export type postApiNewsletterSubscribeResponse = postApiNewsletterSubscribeResponseComposite & {
  headers: Headers;
}

export const getPostApiNewsletterSubscribeUrl = () => {


  

  return `/api/Newsletter/subscribe`
}

export const postApiNewsletterSubscribe = async (subscribeToNewsletterRequest: SubscribeToNewsletterRequest, options?: RequestInit): Promise<postApiNewsletterSubscribeResponse> => {
  
  const res = await fetch(getPostApiNewsletterSubscribeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      subscribeToNewsletterRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiNewsletterSubscribeResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiNewsletterSubscribeResponse
}




export const getPostApiNewsletterSubscribeMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiNewsletterSubscribe>>, TError,{data: SubscribeToNewsletterRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiNewsletterSubscribe>>, TError,{data: SubscribeToNewsletterRequest}, TContext> => {

const mutationKey = ['postApiNewsletterSubscribe'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiNewsletterSubscribe>>, {data: SubscribeToNewsletterRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiNewsletterSubscribe(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiNewsletterSubscribeMutationResult = NonNullable<Awaited<ReturnType<typeof postApiNewsletterSubscribe>>>
    export type PostApiNewsletterSubscribeMutationBody = SubscribeToNewsletterRequest
    export type PostApiNewsletterSubscribeMutationError = ProblemDetails

    export const usePostApiNewsletterSubscribe = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiNewsletterSubscribe>>, TError,{data: SubscribeToNewsletterRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiNewsletterSubscribe>>,
        TError,
        {data: SubscribeToNewsletterRequest},
        TContext
      > => {

      const mutationOptions = getPostApiNewsletterSubscribeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiOpenrouterToolsConversationsConversationIdResponse200 = {
  data: Message[]
  status: 200
}
    
export type getApiOpenrouterToolsConversationsConversationIdResponseComposite = getApiOpenrouterToolsConversationsConversationIdResponse200;
    
export type getApiOpenrouterToolsConversationsConversationIdResponse = getApiOpenrouterToolsConversationsConversationIdResponseComposite & {
  headers: Headers;
}

export const getGetApiOpenrouterToolsConversationsConversationIdUrl = (conversationId: string,) => {


  

  return `/api/openrouter/tools/conversations/${conversationId}`
}

export const getApiOpenrouterToolsConversationsConversationId = async (conversationId: string, options?: RequestInit): Promise<getApiOpenrouterToolsConversationsConversationIdResponse> => {
  
  const res = await fetch(getGetApiOpenrouterToolsConversationsConversationIdUrl(conversationId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiOpenrouterToolsConversationsConversationIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiOpenrouterToolsConversationsConversationIdResponse
}



export const getGetApiOpenrouterToolsConversationsConversationIdQueryKey = (conversationId?: string,) => {
    return [`/api/openrouter/tools/conversations/${conversationId}`] as const;
    }

    
export const getGetApiOpenrouterToolsConversationsConversationIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError = unknown>(conversationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiOpenrouterToolsConversationsConversationIdQueryKey(conversationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>> = ({ signal }) => getApiOpenrouterToolsConversationsConversationId(conversationId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiOpenrouterToolsConversationsConversationIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>>
export type GetApiOpenrouterToolsConversationsConversationIdQueryError = unknown


export function useGetApiOpenrouterToolsConversationsConversationId<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError = unknown>(
 conversationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>,
          TError,
          Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiOpenrouterToolsConversationsConversationId<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError = unknown>(
 conversationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>,
          TError,
          Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiOpenrouterToolsConversationsConversationId<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError = unknown>(
 conversationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiOpenrouterToolsConversationsConversationId<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError = unknown>(
 conversationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsConversationsConversationId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiOpenrouterToolsConversationsConversationIdQueryOptions(conversationId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiOpenrouterToolsModelsResponse200 = {
  data: OpenRouterModel[]
  status: 200
}
    
export type getApiOpenrouterToolsModelsResponseComposite = getApiOpenrouterToolsModelsResponse200;
    
export type getApiOpenrouterToolsModelsResponse = getApiOpenrouterToolsModelsResponseComposite & {
  headers: Headers;
}

export const getGetApiOpenrouterToolsModelsUrl = () => {


  

  return `/api/openrouter/tools/models`
}

export const getApiOpenrouterToolsModels = async ( options?: RequestInit): Promise<getApiOpenrouterToolsModelsResponse> => {
  
  const res = await fetch(getGetApiOpenrouterToolsModelsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiOpenrouterToolsModelsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiOpenrouterToolsModelsResponse
}



export const getGetApiOpenrouterToolsModelsQueryKey = () => {
    return [`/api/openrouter/tools/models`] as const;
    }

    
export const getGetApiOpenrouterToolsModelsQueryOptions = <TData = Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiOpenrouterToolsModelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>> = ({ signal }) => getApiOpenrouterToolsModels({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiOpenrouterToolsModelsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>>
export type GetApiOpenrouterToolsModelsQueryError = unknown


export function useGetApiOpenrouterToolsModels<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>,
          TError,
          Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiOpenrouterToolsModels<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>,
          TError,
          Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiOpenrouterToolsModels<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiOpenrouterToolsModels<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsModels>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiOpenrouterToolsModelsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiOpenrouterToolsChatStreamResponse200 = {
  data: null
  status: 200
}
    
export type getApiOpenrouterToolsChatStreamResponseComposite = getApiOpenrouterToolsChatStreamResponse200;
    
export type getApiOpenrouterToolsChatStreamResponse = getApiOpenrouterToolsChatStreamResponseComposite & {
  headers: Headers;
}

export const getGetApiOpenrouterToolsChatStreamUrl = (params?: GetApiOpenrouterToolsChatStreamParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/openrouter/tools/chat/stream?${stringifiedParams}` : `/api/openrouter/tools/chat/stream`
}

export const getApiOpenrouterToolsChatStream = async (params?: GetApiOpenrouterToolsChatStreamParams, options?: RequestInit): Promise<getApiOpenrouterToolsChatStreamResponse> => {
  
  const res = await fetch(getGetApiOpenrouterToolsChatStreamUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiOpenrouterToolsChatStreamResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiOpenrouterToolsChatStreamResponse
}



export const getGetApiOpenrouterToolsChatStreamQueryKey = (params?: GetApiOpenrouterToolsChatStreamParams,) => {
    return [`/api/openrouter/tools/chat/stream`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiOpenrouterToolsChatStreamQueryOptions = <TData = Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError = unknown>(params?: GetApiOpenrouterToolsChatStreamParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiOpenrouterToolsChatStreamQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>> = ({ signal }) => getApiOpenrouterToolsChatStream(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiOpenrouterToolsChatStreamQueryResult = NonNullable<Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>>
export type GetApiOpenrouterToolsChatStreamQueryError = unknown


export function useGetApiOpenrouterToolsChatStream<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError = unknown>(
 params: undefined |  GetApiOpenrouterToolsChatStreamParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>,
          TError,
          Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiOpenrouterToolsChatStream<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError = unknown>(
 params?: GetApiOpenrouterToolsChatStreamParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>,
          TError,
          Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiOpenrouterToolsChatStream<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError = unknown>(
 params?: GetApiOpenrouterToolsChatStreamParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiOpenrouterToolsChatStream<TData = Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError = unknown>(
 params?: GetApiOpenrouterToolsChatStreamParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiOpenrouterToolsChatStream>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiOpenrouterToolsChatStreamQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiUsersIdResponse200 = {
  data: UserResponse
  status: 200
}
    
export type getApiUsersIdResponseComposite = getApiUsersIdResponse200;
    
export type getApiUsersIdResponse = getApiUsersIdResponseComposite & {
  headers: Headers;
}

export const getGetApiUsersIdUrl = (id: string,) => {


  

  return `/api/Users/${id}`
}

export const getApiUsersId = async (id: string, options?: RequestInit): Promise<getApiUsersIdResponse> => {
  
  const res = await fetch(getGetApiUsersIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiUsersIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiUsersIdResponse
}



export const getGetApiUsersIdQueryKey = (id?: string,) => {
    return [`/api/Users/${id}`] as const;
    }

    
export const getGetApiUsersIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiUsersId>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiUsersIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiUsersId>>> = ({ signal }) => getApiUsersId(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiUsersId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiUsersIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiUsersId>>>
export type GetApiUsersIdQueryError = unknown


export function useGetApiUsersId<TData = Awaited<ReturnType<typeof getApiUsersId>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUsersId>>,
          TError,
          Awaited<ReturnType<typeof getApiUsersId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiUsersId<TData = Awaited<ReturnType<typeof getApiUsersId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUsersId>>,
          TError,
          Awaited<ReturnType<typeof getApiUsersId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiUsersId<TData = Awaited<ReturnType<typeof getApiUsersId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiUsersId<TData = Awaited<ReturnType<typeof getApiUsersId>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiUsersIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type putApiUsersIdResponse200 = {
  data: UpdateUserResponse
  status: 200
}
    
export type putApiUsersIdResponseComposite = putApiUsersIdResponse200;
    
export type putApiUsersIdResponse = putApiUsersIdResponseComposite & {
  headers: Headers;
}

export const getPutApiUsersIdUrl = (id: string,) => {


  

  return `/api/Users/${id}`
}

export const putApiUsersId = async (id: string,
    updateUserRequest: UpdateUserRequest, options?: RequestInit): Promise<putApiUsersIdResponse> => {
  
  const res = await fetch(getPutApiUsersIdUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putApiUsersIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putApiUsersIdResponse
}




export const getPutApiUsersIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiUsersId>>, TError,{id: string;data: UpdateUserRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putApiUsersId>>, TError,{id: string;data: UpdateUserRequest}, TContext> => {

const mutationKey = ['putApiUsersId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiUsersId>>, {id: string;data: UpdateUserRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  putApiUsersId(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiUsersIdMutationResult = NonNullable<Awaited<ReturnType<typeof putApiUsersId>>>
    export type PutApiUsersIdMutationBody = UpdateUserRequest
    export type PutApiUsersIdMutationError = unknown

    export const usePutApiUsersId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiUsersId>>, TError,{id: string;data: UpdateUserRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiUsersId>>,
        TError,
        {id: string;data: UpdateUserRequest},
        TContext
      > => {

      const mutationOptions = getPutApiUsersIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type deleteApiUsersIdResponse200 = {
  data: DeleteUserResponse
  status: 200
}
    
export type deleteApiUsersIdResponseComposite = deleteApiUsersIdResponse200;
    
export type deleteApiUsersIdResponse = deleteApiUsersIdResponseComposite & {
  headers: Headers;
}

export const getDeleteApiUsersIdUrl = (id: string,) => {


  

  return `/api/Users/${id}`
}

export const deleteApiUsersId = async (id: string, options?: RequestInit): Promise<deleteApiUsersIdResponse> => {
  
  const res = await fetch(getDeleteApiUsersIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteApiUsersIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteApiUsersIdResponse
}




export const getDeleteApiUsersIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiUsersId>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiUsersId>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteApiUsersId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiUsersId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteApiUsersId(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiUsersIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiUsersId>>>
    
    export type DeleteApiUsersIdMutationError = unknown

    export const useDeleteApiUsersId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiUsersId>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiUsersId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteApiUsersIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiUsersMeResponse200 = {
  data: UserResponse
  status: 200
}
    
export type getApiUsersMeResponseComposite = getApiUsersMeResponse200;
    
export type getApiUsersMeResponse = getApiUsersMeResponseComposite & {
  headers: Headers;
}

export const getGetApiUsersMeUrl = () => {


  

  return `/api/Users/me`
}

export const getApiUsersMe = async ( options?: RequestInit): Promise<getApiUsersMeResponse> => {
  
  const res = await fetch(getGetApiUsersMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiUsersMeResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiUsersMeResponse
}



export const getGetApiUsersMeQueryKey = () => {
    return [`/api/Users/me`] as const;
    }

    
export const getGetApiUsersMeQueryOptions = <TData = Awaited<ReturnType<typeof getApiUsersMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersMe>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiUsersMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiUsersMe>>> = ({ signal }) => getApiUsersMe({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiUsersMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiUsersMeQueryResult = NonNullable<Awaited<ReturnType<typeof getApiUsersMe>>>
export type GetApiUsersMeQueryError = unknown


export function useGetApiUsersMe<TData = Awaited<ReturnType<typeof getApiUsersMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUsersMe>>,
          TError,
          Awaited<ReturnType<typeof getApiUsersMe>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiUsersMe<TData = Awaited<ReturnType<typeof getApiUsersMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUsersMe>>,
          TError,
          Awaited<ReturnType<typeof getApiUsersMe>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiUsersMe<TData = Awaited<ReturnType<typeof getApiUsersMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersMe>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiUsersMe<TData = Awaited<ReturnType<typeof getApiUsersMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersMe>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiUsersMeQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type getApiUsersResponse200 = {
  data: GetAllUsersResponse
  status: 200
}
    
export type getApiUsersResponseComposite = getApiUsersResponse200;
    
export type getApiUsersResponse = getApiUsersResponseComposite & {
  headers: Headers;
}

export const getGetApiUsersUrl = (params?: GetApiUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/Users?${stringifiedParams}` : `/api/Users`
}

export const getApiUsers = async (params?: GetApiUsersParams, options?: RequestInit): Promise<getApiUsersResponse> => {
  
  const res = await fetch(getGetApiUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiUsersResponse
}



export const getGetApiUsersQueryKey = (params?: GetApiUsersParams,) => {
    return [`/api/Users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiUsersQueryOptions = <TData = Awaited<ReturnType<typeof getApiUsers>>, TError = unknown>(params?: GetApiUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsers>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiUsers>>> = ({ signal }) => getApiUsers(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getApiUsers>>>
export type GetApiUsersQueryError = unknown


export function useGetApiUsers<TData = Awaited<ReturnType<typeof getApiUsers>>, TError = unknown>(
 params: undefined |  GetApiUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUsers>>,
          TError,
          Awaited<ReturnType<typeof getApiUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiUsers<TData = Awaited<ReturnType<typeof getApiUsers>>, TError = unknown>(
 params?: GetApiUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUsers>>,
          TError,
          Awaited<ReturnType<typeof getApiUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiUsers<TData = Awaited<ReturnType<typeof getApiUsers>>, TError = unknown>(
 params?: GetApiUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiUsers<TData = Awaited<ReturnType<typeof getApiUsers>>, TError = unknown>(
 params?: GetApiUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiUsersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postApiUsersResponse200 = {
  data: CreateUserResponse
  status: 200
}
    
export type postApiUsersResponseComposite = postApiUsersResponse200;
    
export type postApiUsersResponse = postApiUsersResponseComposite & {
  headers: Headers;
}

export const getPostApiUsersUrl = () => {


  

  return `/api/Users`
}

export const postApiUsers = async (createUserRequest: CreateUserRequest, options?: RequestInit): Promise<postApiUsersResponse> => {
  
  const res = await fetch(getPostApiUsersUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiUsersResponse
}




export const getPostApiUsersMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiUsers>>, TError,{data: CreateUserRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiUsers>>, TError,{data: CreateUserRequest}, TContext> => {

const mutationKey = ['postApiUsers'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiUsers>>, {data: CreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiUsers(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postApiUsers>>>
    export type PostApiUsersMutationBody = CreateUserRequest
    export type PostApiUsersMutationError = unknown

    export const usePostApiUsers = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiUsers>>, TError,{data: CreateUserRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiUsers>>,
        TError,
        {data: CreateUserRequest},
        TContext
      > => {

      const mutationOptions = getPostApiUsersMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type postApiUsersIdRolesResponse200 = {
  data: null
  status: 200
}
    
export type postApiUsersIdRolesResponseComposite = postApiUsersIdRolesResponse200;
    
export type postApiUsersIdRolesResponse = postApiUsersIdRolesResponseComposite & {
  headers: Headers;
}

export const getPostApiUsersIdRolesUrl = (id: string,) => {


  

  return `/api/Users/${id}/roles`
}

export const postApiUsersIdRoles = async (id: string,
    assignRoleRequest: AssignRoleRequest, options?: RequestInit): Promise<postApiUsersIdRolesResponse> => {
  
  const res = await fetch(getPostApiUsersIdRolesUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      assignRoleRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postApiUsersIdRolesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postApiUsersIdRolesResponse
}




export const getPostApiUsersIdRolesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiUsersIdRoles>>, TError,{id: string;data: AssignRoleRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postApiUsersIdRoles>>, TError,{id: string;data: AssignRoleRequest}, TContext> => {

const mutationKey = ['postApiUsersIdRoles'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiUsersIdRoles>>, {id: string;data: AssignRoleRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postApiUsersIdRoles(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiUsersIdRolesMutationResult = NonNullable<Awaited<ReturnType<typeof postApiUsersIdRoles>>>
    export type PostApiUsersIdRolesMutationBody = AssignRoleRequest
    export type PostApiUsersIdRolesMutationError = unknown

    export const usePostApiUsersIdRoles = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiUsersIdRoles>>, TError,{id: string;data: AssignRoleRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiUsersIdRoles>>,
        TError,
        {id: string;data: AssignRoleRequest},
        TContext
      > => {

      const mutationOptions = getPostApiUsersIdRolesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export type getApiUsersIdRolesResponse200 = {
  data: UserRolesResponse
  status: 200
}
    
export type getApiUsersIdRolesResponseComposite = getApiUsersIdRolesResponse200;
    
export type getApiUsersIdRolesResponse = getApiUsersIdRolesResponseComposite & {
  headers: Headers;
}

export const getGetApiUsersIdRolesUrl = (id: string,) => {


  

  return `/api/Users/${id}/roles`
}

export const getApiUsersIdRoles = async (id: string, options?: RequestInit): Promise<getApiUsersIdRolesResponse> => {
  
  const res = await fetch(getGetApiUsersIdRolesUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getApiUsersIdRolesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getApiUsersIdRolesResponse
}



export const getGetApiUsersIdRolesQueryKey = (id?: string,) => {
    return [`/api/Users/${id}/roles`] as const;
    }

    
export const getGetApiUsersIdRolesQueryOptions = <TData = Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiUsersIdRolesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiUsersIdRoles>>> = ({ signal }) => getApiUsersIdRoles(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiUsersIdRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiUsersIdRoles>>>
export type GetApiUsersIdRolesQueryError = unknown


export function useGetApiUsersIdRoles<TData = Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUsersIdRoles>>,
          TError,
          Awaited<ReturnType<typeof getApiUsersIdRoles>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiUsersIdRoles<TData = Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiUsersIdRoles>>,
          TError,
          Awaited<ReturnType<typeof getApiUsersIdRoles>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiUsersIdRoles<TData = Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetApiUsersIdRoles<TData = Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiUsersIdRoles>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiUsersIdRolesQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
